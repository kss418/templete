{
"hld": {
  "prefix": ">>hld",
  "body": [
    "template <class P>",
    "concept is_action = requires(P s, int l, int r, const typename P::lazy& z){ s.update(l, r, z); };",
    "",
    "template <class policy>",
    "class _hld { // 1-based index, m=0 vertex, m=1 edge(child-index)",
    "public:",
    "    using node = typename policy::node;",
    "    policy seg;",
    "private:",
    "    vector <vector <int>> adj, tmp;",
    "    vector <int> sz, top, d, in, out, p;",
    "    int n, m, cnt = 0; bool built = 0;",
    "    void build_tree(int cur, int pre = -1){",
    "        for(auto& nxt : tmp[cur]){",
    "            if(pre == nxt) continue;",
    "            adj[cur].push_back(nxt);",
    "            build_tree(nxt, cur);",
    "        }",
    "        tmp[cur].clear();",
    "    }",
    "",
    "    void dfs1(int cur){",
    "        sz[cur] = 1;",
    "        for(auto& nxt : adj[cur]){",
    "            d[nxt] = d[cur] + 1; p[nxt] = cur;",
    "            dfs1(nxt); sz[cur] += sz[nxt];",
    "            if(sz[nxt] > sz[adj[cur][0]]) swap(nxt, adj[cur][0]);",
    "        }",
    "    }",
    "",
    "    void dfs2(int cur){",
    "        in[cur] = ++cnt;",
    "        for(auto& nxt : adj[cur]){",
    "            top[nxt] = (nxt == adj[cur][0] ? top[cur] : nxt);",
    "            dfs2(nxt);",
    "        }",
    "        out[cur] = cnt;",
    "    }",
    "",
    "    vector<pair<int,int>> get_path(int st, int en){",
    "        vector<pair<int,int>> ret;",
    "        while(top[st] != top[en]){",
    "            if(d[top[st]] < d[top[en]]) swap(st, en);",
    "            int cur = top[st], l = in[cur], r = in[st];",
    "            if(m == 1 && p[cur] == 0) l++; ",
    "            if(l <= r) ret.push_back({l, r});",
    "            st = p[cur];",
    "        }",
    "        if(d[st] > d[en]) swap(st, en);",
    "        int l = in[st] + m, r = in[en];",
    "        if(l <= r) ret.push_back({l, r});",
    "        return ret;",
    "    }",
    "public:",
    "    _hld(int n = 0, int m = 0){ clear(n, m); }",
    "    void clear(int n, int m = 0){",
    "        this->n = n; this->m = m; cnt = 0;",
    "        adj.assign(n + 1, {}); tmp.assign(n + 1, {}); ",
    "        top.assign(n + 1, 0); d.assign(n + 1, 0); ",
    "        in.assign(n + 1, 0); out.assign(n + 1, 0);",
    "        p.assign(n + 1, 0); sz.assign(n + 1, 0);",
    "        seg.clear(n); built = 0;",
    "    }",
    "",
    "    void addsol(int s, int e){ tmp[s].push_back(e); }",
    "    void add(int s, int e){ addsol(s, e); addsol(e, s); }",
    "    void init(){",
    "        assert(!built); built = 1;",
    "        for(int i = 1;i <= n;i++){",
    "            if(sz[i]) continue; top[i] = i;",
    "            build_tree(i); dfs1(i); dfs2(i);",
    "        }",
    "        tmp.clear(); tmp.shrink_to_fit();",
    "    }",
    "",
    "    node query(int x){",
    "        assert(built);",
    "        return seg.query(in[x], in[x]);",
    "    }",
    "",
    "    node query(int st, int en) { ",
    "        assert(built); node ret = seg.id();",
    "        auto path = get_path(st, en);",
    "        for(auto &[l, r] : path) ret = seg.op(ret, seg.query(l, r));",
    "        return ret;",
    "    }",
    "",
    "    node query_sub(int x){ assert(built); return seg.query(in[x] + m, out[x]); }",
    "    void set(int x, const node& v)",
    "        requires requires(policy s, int i, const node& nv){ s.set(i, nv); }",
    "    { assert(built); seg.set(in[x], v); }",
    "",
    "    void update(int x, const node& v)",
    "        requires requires(policy s, int i, const node& nv){ s.update(i, nv); }",
    "    { assert(built); seg.update(in[x], v); }",
    "",
    "    template<class P = policy>",
    "    void update(int st, int en, const typename P::lazy& lz)",
    "        requires is_action<P>",
    "    {",
    "        auto path = get_path(st, en); assert(built);",
    "        for(auto &[l, r] : path) seg.update(l, r, lz);",
    "    }",
    "",
    "    template<class P = policy>",
    "    void update_sub(int x, const typename P::lazy& lz)",
    "        requires is_action<P>",
    "    { assert(built); seg.update(in[x] + m, out[x], lz); }",
    "}; "
  ],
  "description": "hld"
}
}
