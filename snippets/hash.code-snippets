{
"hash": {
  "prefix": ">>hash",
  "body": [
    "class _hash{ // 0-based index",
    "private:",
    "    class _core {",
    "    public:",
    "        vector <_mint> pw, ipw, pre; ",
    "        _mint key, inv; ll mod; ",
    "        _core() : mod(1), key(1, 0), inv(1, 0){}",
    "        _core(ll key, ll mod) : mod(mod), key(mod, key){ // O(n)",
    "            assert(mod > 1); assert(this->key.v > 0);",
    "            inv = this->key.inv();",
    "            pw.push_back(_mint(1, mod)); ipw.push_back(_mint(1, mod));",
    "        }",
    "",
    "        void ensure_pw(int k){ ",
    "            while((int)pw.size() <= k){",
    "                pw.push_back(pw.back() * key); ",
    "                ipw.push_back(ipw.back() * inv);",
    "            }",
    "        }",
    "",
    "        int size() const{ return (int)pre.size(); }",
    "        void push_back(ll v){ // O(1)",
    "            _mint now = _mint(v, mod); ensure_pw(size());",
    "            if(pre.empty()) pre.push_back(now);",
    "            else pre.push_back(pre.back() + now * pw[size()]);",
    "        }",
    "",
    "        void pop_back(){ // O(1)",
    "            assert(!pre.empty());",
    "            pre.pop_back();",
    "        }",
    "",
    "        ll ret(int l, int r) const{ // O(1)",
    "            _mint ret = pre[r];",
    "            if(l > 0) ret -= pre[l - 1];",
    "            ret *= ipw[l];",
    "            return ret.v;",
    "        }",
    "    }; vector <_core> arr; int m;",
    "public:",
    "    _hash() : m(0){} ",
    "    _hash(const vector <ll>& key, const vector<ll>& mod){ // O(n)",
    "        assert(key.size() == mod.size()); m = key.size(); arr.reserve(m);",
    "        for(int i = 0; i < mod.size(); i++) arr.emplace_back(key[i], mod[i]);",
    "    }",
    "",
    "    void push_back(ll v){ for(auto& c : arr) c.push_back(v); } // O(1)",
    "    void pop_back(){ for(auto& c : arr) c.pop_back(); } // O(1)",
    "    int size() const{ return arr.empty() ? 0 : arr[0].size(); } // O(1)",
    "    vector<ll> ret(int l, int r) const{ // O(1)",
    "        vector<ll> ret; ret.reserve(m);",
    "        for(const auto& c : arr) ret.push_back(c.ret(l, r));",
    "        return ret;",
    "    }",
    "",
    "    bool same(int l1, int r1, int l2, int r2) const{ // O(1)",
    "        for(const auto& c : arr) if(c.ret(l1, r1) != c.ret(l2, r2)) return 0;",
    "        return 1;",
    "    }",
    "};"
  ],
  "description": "hash"
}
}
