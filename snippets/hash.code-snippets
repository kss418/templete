{
"hash": {
  "prefix": ">>hash",
  "body": [
    "class _hash{ // 0-based index",
    "private:",
    "    using pi = pair<int, int>;",
    "    class _core {",
    "    public:",
    "        vector <int> pw, pre, ipw; ",
    "        _mint key, inv; int mod; ",
    "        _core(){};",
    "        _core(int key, int mod) : mod(mod), key(key, mod){ // O(n)",
    "            assert(mod > 1); assert(this->key.v > 0);",
    "            pre.clear(); pw.clear(); ipw.clear();",
    "            pw.push_back(1); ipw.push_back(1); inv = this->key.inv();",
    "        }",
    "",
    "        void ensure_pw(int k){ ",
    "            while((int)pw.size() <= k){",
    "                pw.push_back((_mint(pw.back(), mod) * key).v); ",
    "                ipw.push_back((_mint(ipw.back(), mod) * inv).v); ",
    "            }",
    "        }",
    "",
    "        int size() const{ return (int)pre.size(); }",
    "        void push_back(int v){ // O(1)",
    "            _mint now = _mint(v, mod); ensure_pw(size());",
    "            if(pre.empty()) pre.push_back(now.v);",
    "            else pre.push_back((_mint(pre.back(), mod) + now * pw[size()]).v);",
    "        }",
    "",
    "        void pop_back(){ // O(1)",
    "            assert(!pre.empty());",
    "            pre.pop_back();",
    "        }",
    "",
    "        ll ret(int l, int r) const{ // O(1)",
    "            _mint ret = _mint(pre[r], mod);",
    "            if(l > 0) ret -= _mint(pre[l - 1], mod);",
    "            ret *= ipw[l];",
    "            return ret.v;",
    "        }",
    "    }; array <_core, 2> arr; ",
    "public:",
    "    _hash(pi key = {1, 1}, pi mod = {2, 2}){ clear(key, mod); }",
    "    void clear(pi key, pi mod){",
    "        arr[0] = {key.x, mod.x}; arr[1] = {key.y, mod.y};",
    "    } ",
    "",
    "    void reset(){ arr[0].pre.clear(); arr[1].pre.clear(); }",
    "    void push_back(int v){ for(auto& c : arr) c.push_back(v); } // O(1)",
    "    void pop_back(){ for(auto& c : arr) c.pop_back(); } // O(1)",
    "    int size() const{ return arr.empty() ? 0 : arr[0].size(); } // O(1)",
    "    ll ret(int l, int r) const{ // O(1)",
    "        return ((ll)arr[0].ret(l, r) << 32) + arr[1].ret(l, r);",
    "    }",
    "",
    "    bool same(int l1, int r1, int l2, int r2) const{ // O(1)",
    "        for(const auto& c : arr) if(c.ret(l1, r1) != c.ret(l2, r2)) return 0;",
    "        return 1;",
    "    }",
    "};"
  ],
  "description": "hash"
}
}
