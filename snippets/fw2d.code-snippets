{
"fenwick 2d": {
  "prefix": ">>fw2d",
  "body": [
    "template <class policy>",
    "concept has_inv = requires(const typename policy::node& a){",
    "    { policy::inv(a) } -> std::same_as<typename policy::node>;",
    "};",
    "",
    "struct group{",
    "    struct node{",
    "        ll v;",
    "        node(ll v = 0) : v(v){}",
    "    };",
    "    static node op(const node& l, const node& r){",
    "        return {l.v + r.v};",
    "    }",
    "    static node inv(const node& a){",
    "        return {-a.v};",
    "    }",
    "};",
    "",
    "template <class policy = group>",
    "class _fw2d{",
    "private:",
    "    using node = typename policy::node;",
    "    vector<vector<node>> bit; int n, m;",
    "    node op(const node& l, const node& r) const { return policy::op(l, r); }",
    "    node id() const { return node(); }",
    "    node inv(const node& a) const { return policy::inv(a); }",
    "public:",
    "    _fw2d(int n = 0, int m = 0){ clear(n, m); } // O(nm)",
    "    void clear(int n, int m){ // O(nm)",
    "        this->n = n; this->m = m;",
    "        bit.assign(n + 2, vector<node>(m + 2, id()));",
    "    }",
    "",
    "    // return (0,0) ~ (y,x)",
    "    node pre(int y, int x){ // O(log n log m)",
    "        if(x < 0 || y < 0) return id();",
    "        node ret = id(); x = min(x, m); y = min(y, n);",
    "        for(int i = y + 1; i > 0; i -= i & -i){",
    "            for(int j = x + 1; j > 0; j -= j & -j){",
    "                ret = op(ret, bit[i][j]);",
    "            }",
    "        }",
    "        return ret;",
    "    }",
    "",
    "    // range query -> need inv",
    "    node query(int y, int x) requires has_inv<policy> { return query(y, x, y, x); } // O(log n log m)",
    "    node query(int y1, int x1, int y2, int x2) requires has_inv<policy> { // O(log n log m)",
    "        x1 = max(x1, 0); y1 = max(y1, 0);",
    "        x2 = min(x2, m); y2 = min(y2, n);",
    "        if(x1 > x2 || y1 > y2) return id();",
    "        node a = pre(y2, x2), b = pre(y2, x1 - 1);",
    "        node c = pre(y1 - 1, x2), d = pre(y1 - 1, x1 - 1);",
    "        node ab = op(a, inv(b)), cd = op(inv(c), d);",
    "        return op(ab, cd);",
    "    }",
    "",
    "    void update(int y, int x, const node& v){ // O(log n log m)",
    "        if(x < 0 || y < 0 || x > m || y > n) return;",
    "        for(int i = y + 1; i <= n + 1; i += i & -i){",
    "            for(int j = x + 1; j <= m + 1; j += j & -j){",
    "                bit[i][j] = op(bit[i][j], v);",
    "            }",
    "        }",
    "    }",
    "",
    "    void set(int y, int x, const node& v) requires has_inv<policy> { // O(log n log m)",
    "        if(x < 0 || y < 0 || x > m || y > n) return;",
    "        node cur = query(y, x), d = op(v, inv(cur));",
    "        update(y, x, d);",
    "    }",
    "};"
  ],
  "description": "fenwick 2d"
}
}
