{
	"sa": {
  "prefix": ">>sa",
  "body": [
    "template <class T = ll>",
    "class _sa{",
    "private:",
    "    vector <T> arr; vector <int> sa, pos, lcp, cnt, tmp_sa; int n, d; ",
    "    void build(){ build_sa(); build_lcp(); }",
    "    template <class F>",
    "    void counting_sort(int sz, const F& f){",
    "        cnt.assign(sz, 0);",
    "        for(int i = 0;i < n;i++) cnt[f(sa[i])]++;",
    "        for(int i = 1;i < sz;i++) cnt[i] += cnt[i - 1];",
    "        for(int i = n - 1;i >= 0;i--) tmp_sa[--cnt[f(sa[i])]] = sa[i];",
    "        sa.swap(tmp_sa);",
    "    }",
    "",
    "    void build_sa(){",
    "        vector <int> tmp(n); vector <pair<T, int>> num; ",
    "        for(int i = 0;i < n;i++) num.push_back({arr[i], i});",
    "        sort(all(num)); pos[num[0].y] = 0;",
    "        tmp_sa.resize(n); int r = 0;",
    "        for(int i = 1; i < n; i++){",
    "            if(num[i].x != num[i - 1].x) r++;",
    "            pos[num[i].y] = r;",
    "        }",
    "        for(d = 1; ;d <<= 1){",
    "            int sz = r + 1;",
    "            counting_sort(sz + 1, [&](int i){ return i + d < n ? pos[i + d] + 1 : 0; });",
    "            counting_sort(sz + 1, [&](int i){ return pos[i] + 1; });",
    "            tmp[sa[0]] = 0; int nr = 0;",
    "            for(int i = 1;i < n;i++){",
    "                int pre = sa[i - 1], cur = sa[i];",
    "                int p1 = pos[pre], c1 = pos[cur];",
    "                int p2 = pre + d < n ? pos[pre + d] : -1;",
    "                int c2 = cur + d < n ? pos[cur + d] : -1;",
    "                if(p1 != c1 || p2 != c2) nr++; tmp[cur] = nr;",
    "            }",
    "            for(int i = 0;i < n;i++) pos[i] = tmp[i]; r = nr;",
    "            if(r == n - 1) break;",
    "        }",
    "    }",
    "",
    "    void build_lcp(){",
    "        int k = 0;",
    "        for(int cur = 0;cur < n;cur++){",
    "            k = max(k - 1, 0);",
    "            if(pos[cur] == n - 1) continue;",
    "            int nxt = sa[pos[cur] + 1];",
    "            while(cur + k < n && nxt + k < n && arr[cur + k] == arr[nxt + k]) k++;",
    "            lcp[pos[cur]] = k;",
    "        }",
    "    }",
    "public:",
    "    _sa(){ clear(0); } // O(1)",
    "    _sa(const string& s){ set(s); } // O(n log n)",
    "    _sa(span<const T> v) { set(v); } // O(n log n)",
    "    void set(const string& s){ clear(s.size()); for(auto& i : s) arr.push_back((T)i); build(); } // O(n log n)",
    "    void set(span<const T> v){ clear(v.size()); this->arr.assign(all(v)); build(); } // O(n log n)",
    "",
    "    void clear(int n){ // O(n)",
    "        this->n = n; d = 1; sa.assign(n, 0); arr.clear(); arr.reserve(n);",
    "        iota(all(sa), 0); lcp.assign(n, 0); pos.assign(n, 0);",
    "    }",
    "",
    "    const vector<int>& get_sa() const{ return sa; } // O(1)",
    "    const vector<int>& get_pos() const{ return pos; } // O(1)",
    "    const vector<int>& get_lcp() const{ return lcp; } // O(1)",
    "};"
  ],
  "description": "sa"
}
}
