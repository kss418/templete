{
  "ac": {
    "prefix": ">>ac",
    "body": [
      "template <int M = 26>",
      "class _ac{",
      "private:",
      "    vector <array<int, M>> adj;",
      "    vector<int> cnt, f, dep, dict; ",
      "    vector <bool> end; bool built;",
      "    vector <int> tf(const string& s) const{",
      "        vector <int> ret; ret.reserve(s.size());",
      "        for(auto& i : s){",
      "            if('a' <= i && i <= 'z') ret.push_back(i - 'a');",
      "            else if('A' <= i && i <= 'Z') ret.push_back(i - 'A');",
      "            else ret.push_back(i - '0');",
      "        }",
      "        return ret;",
      "    }",
      "",
      "    int new_node(){",
      "        adj.push_back(array<int, M>{}); f.push_back(0); cnt.push_back(0);",
      "        end.push_back(0); dict.push_back(0); dep.push_back(0);",
      "        return (int)adj.size() - 1;",
      "    }",
      "public:",
      "    _ac(){ clear(); } // O(1)",
      "    void clear(){ // O(1)",
      "        built = 0; adj.clear(); end.clear(); dep.clear();",
      "        f.clear(); cnt.clear(); dict.clear(); new_node();",
      "    }",
      "    ",
      "    void reserve(int max_node){ // O(1)",
      "        adj.reserve(max_node); f.reserve(max_node); dep.reserve(max_node);",
      "        cnt.reserve(max_node); end.reserve(max_node); dict.reserve(max_node);",
      "    }",
      "",
      "    const vector<int>& depth() const{ return dep; }",
      "    const vector<bool>& terminal() const{ return end; }",
      "    int size() const{ return (int)adj.size(); } // O(1)",
      "    void insert(const string& s){ auto v = tf(s); insert(v); } // O(|s|)",
      "    void insert(span<const int> v){ // O(|v|)",
      "        assert(!built); int cur = 0;",
      "        for(auto &c : v){",
      "            assert(0 <= c && c < M);",
      "            int nxt = adj[cur][c];",
      "            if(!nxt){",
      "                nxt = new_node();",
      "                adj[cur][c] = nxt;",
      "                dep[nxt] = dep[cur] + 1;",
      "            }",
      "            cur = adj[cur][c];",
      "        }",
      "        end[cur] = 1; cnt[cur]++;",
      "    }",
      "    ",
      "    void build(){ // O(max_node * m)",
      "        assert(!built); built = 1; deque <int> q;",
      "        for(int c = 0;c < M;c++){",
      "            int nxt = adj[0][c];",
      "            if(!nxt) continue;",
      "            f[nxt] = 0; dict[nxt] = 0; q.push_back(nxt);",
      "        }",
      "        ",
      "        while(!q.empty()){",
      "            int cur = q.front(); q.pop_front();",
      "            cnt[cur] += cnt[f[cur]];",
      "            dict[cur] = end[f[cur]] ? f[cur] : dict[f[cur]];",
      "            for(int c = 0;c < M;c++){",
      "                int nxt = adj[cur][c];",
      "                if(!nxt) adj[cur][c] = adj[f[cur]][c];",
      "                else{",
      "                    f[nxt] = adj[f[cur]][c];",
      "                    q.push_back(nxt);",
      "                }",
      "            }",
      "        }",
      "    }",
      "",
      "    ll count(const string& s) const{ auto v = tf(s); return count(v); } // O(|s|)",
      "    ll count(span<const int> v) const{ // O(|v|)",
      "        assert(built); ll ret = 0;",
      "        it_state(v, [&](int st){ ret += cnt[st]; });",
      "        return ret;",
      "    }",
      "",
      "    int go(int state, int c) const{ // O(1)",
      "        assert(0 <= c && c < M && built);",
      "        return adj[state][c];",
      "    }",
      "",
      "    template <class F> ",
      "    void it_state(const string& s, const F& f) const{ auto v = tf(s); it_state(v, f); } // O(|s|)",
      "    template <class F> ",
      "    void it_state(span<const int> v, const F& f) const{ // O(|v|)",
      "        assert(built); int cur = 0;",
      "        for(auto& c : v){",
      "            assert(0 <= c && c < M);",
      "            cur = go(cur, c), f(cur);",
      "        }",
      "    }",
      "",
      "    int max_match_len(int state) const{ // O(1)",
      "        assert(built);",
      "        return end[state] ? dep[state] : (dict[state] ? dep[dict[state]] : 0);",
      "    }",
      "",
      "    template <class F>",
      "    void it_match_lens(int state, const F& f) const{ it_match_lens(state, 0x3f3f3f3f, f); } // O(min(k, matches))",
      "    template <class F>",
      "    void it_match_lens(int state, int k, const F& f) const{ // O(min(k, matches))",
      "        assert(built); if(k <= 0) return; int cnt = 0;",
      "        if(end[state]){",
      "            f(dep[state]); if(++cnt >= k) return;",
      "        }",
      "        for(int x = dict[state];x > 0 && cnt < k;x = dict[x]) f(dep[x]), ++cnt;",
      "    }",
      "};"
    ],
    "description": "ac"
  }
}
