{
	"mos": {
  "prefix": ">>mos",
  "body": [
    "struct mos_policy{",
    "    struct node{",
    "        ll v;",
    "        node(ll v = 0) : v(v){}",
    "    };",
    "    struct ret{",
    "        ll v;",
    "        ret(ll v = 0) : v(v){}",
    "    };",
    "    static void push_front(int idx, const node& v, ret& cur){",
    "",
    "    }",
    "    static void push_back(int idx, const node& v, ret& cur){",
    "        push_front(idx, v, cur);",
    "    }",
    "    static void pop_front(int idx, const node& v, ret& cur){",
    "",
    "    }",
    "    static void pop_back(int idx, const node& v, ret& cur){",
    "        pop_front(idx, v, cur);",
    "    }",
    "};",
    "",
    "template <class policy = mos_policy>",
    "class _mos{",
    "public:",
    "    using node = typename policy::node;",
    "    using ret  = typename policy::ret;",
    "private:",
    "    int n, b, cl = 0, cr = -1; ret cur = ret_id();",
    "    static void push_front(int idx, const node& v, ret& cur){ policy::push_front(idx, v, cur); }",
    "    static void push_back(int idx, const node& v, ret& cur){ policy::push_back(idx, v, cur); }",
    "    static void pop_front(int idx, const node& v, ret& cur){ policy::pop_front(idx, v, cur); }",
    "    static void pop_back(int idx, const node& v, ret& cur){ policy::pop_back(idx, v, cur); }",
    "    static node node_id(){ return node(); }",
    "    static ret ret_id(){ return ret();  }",
    "    struct query{ int l, r, idx; };",
    "    struct cmp {",
    "        int b;",
    "        bool operator()(const query& a, const query& c) const {",
    "            int ab = a.l / b, cb = c.l / b;",
    "            if(ab != cb) return ab < cb;",
    "            if(ab & 1) return a.r > c.r;",
    "            return a.r < c.r;",
    "        }",
    "    };",
    "    void apply(int nl, int nr){",
    "        while(cl > nl){ --cl; push_front(cl, arr[cl], cur); }",
    "        while(cr < nr){ ++cr; push_back(cr, arr[cr], cur); }",
    "        while(cl < nl){ pop_front(cl, arr[cl], cur); ++cl; }",
    "        while(cr > nr){ pop_back(cr, arr[cr], cur); --cr; }",
    "    }",
    "public:",
    "    vector <ret> result; vector <node> arr; vector <query> vq;",
    "    _mos(int n = 0, int b = 0){ clear(n, b); } // O(n)",
    "    void clear(int n, int b = 0){ // O(n)",
    "        this->n = n; this->b = b;",
    "        if(!b) this->b = sqrt(n + 1); vq.clear();",
    "        arr.assign(n + 1, node_id()); result.clear();",
    "        cl = 0; cr = -1; cur = ret_id();",
    "    }",
    "",
    "    const vector<ret>& get_result() const{ return result; } // O(1)",
    "    void add(int l, int r){ vq.push_back({l, r, (int)vq.size()}); } // O(1)",
    "    void set(int idx, const node& v){ arr[idx] = v; } // O(1)",
    "    void build(){ // O(q log q + (n^2 / b + qb) * update)",
    "        if (vq.empty()) { result.clear(); return; } ",
    "        sort(all(vq), cmp{b}); result.assign(vq.size(), ret_id());",
    "        for(const auto& cq : vq){",
    "            apply(cq.l, cq.r);",
    "            result[cq.idx] = cur;",
    "        }",
    "    }",
    "};"
  ],
  "description": "mos"
}
}
