{
	"mos": {
  "prefix": ">>mos",
  "body": [
    "struct mos_policy{",
    "    struct node{",
    "        ll v;",
    "        node(ll v = 0) : v(v){}",
    "    };",
    "    struct ret{",
    "        ll v;",
    "        ret(ll v = 0) : v(v){}",
    "    };",
    "    static void push_front(int idx, const node& v, ret& now){}",
    "    static void push_back(int idx, const node& v, ret& now){}",
    "    static void pop_front(int idx, const node& v, ret& now){}",
    "    static void pop_back(int idx, const node& v, ret& now){}",
    "};",
    "",
    "template <class policy = mos_policy>",
    "class _mos{",
    "public:",
    "    using node = typename policy::node;",
    "    using ret  = typename policy::ret;",
    "private:",
    "    int n, b;",
    "    static void push_front(int idx, const node& v, ret& now){ policy::push_front(idx, v, now); }",
    "    static void push_back(int idx, const node& v, ret& now){ policy::push_back(idx, v, now); }",
    "    static void pop_front(int idx, const node& v, ret& now){ policy::pop_front(idx, v, now); }",
    "    static void pop_back(int idx, const node& v, ret& now){ policy::pop_back(idx, v, now); }",
    "    static node node_id(){ return node(); }",
    "    static ret ret_id(){ return ret();  }",
    "    struct query{ int l, r, idx; };",
    "    struct cmp {",
    "        int b;",
    "        bool operator()(const query& a, const query& c) const {",
    "            int ab = a.l / b, cb = c.l / b;",
    "            return (ab != cb ? ab < cb : a.r < c.r);",
    "        }",
    "    };",
    "public:",
    "    vector <ret> result; vector <node> arr; vector <query> vq;",
    "    _mos(int n = 0, int b = 0){ clear(n, b); }",
    "    void clear(int n, int b = 0){",
    "        this->n = n; this->b = b;",
    "        if(!b) this->b = sqrt(n); vq.clear();",
    "        arr.assign(n + 1, node_id());",
    "    }",
    "",
    "    const vector<ret>& get_result() const{ return result; }",
    "    void add(int l, int r, int idx){ vq.push_back({l, r, idx}); }",
    "    void set(int idx, const node& v){ arr[idx] = v; }",
    "    void build(){",
    "        if (vq.empty()) { result.clear(); return; } ",
    "        sort(all(vq), cmp{b}); result.assign(vq.size() + 1, ret_id());",
    "        int s = vq[0].l, e = s - 1; ret cur = ret_id();",
    "        while(e < vq[0].r){ ++e; push_back(e, arr[e], cur); }",
    "        while(s > vq[0].l){ --s; push_front(s, arr[s], cur); }",
    "        while(s < vq[0].l){ pop_front(s, arr[s], cur); ++s; }",
    "        result[vq[0].idx] = cur;",
    "        for(int i = 1;i < (int)vq.size();i++){",
    "            auto&[l, r, idx] = vq[i];",
    "            while(l > s){ pop_front(s, arr[s], cur); ++s; }",
    "            while(r < e){ pop_back(e,  arr[e],  cur); --e; }",
    "            while(l < s){ --s; push_front(s, arr[s], cur); }",
    "            while(r > e){ ++e; push_back(e,  arr[e],  cur); }",
    "            result[idx] = cur;",
    "        }",
    "    }",
    "};"
  ],
  "description": "mos"
}
}
