{
"cht": {
  "prefix": ">>cht",
  "body": [
    "class _cht{",
    "public:",
    "    class line{",
    "    public:",
    "        ll a, b; line(){}",
    "        line(ll a, ll b) : a(a), b(b){}",
    "        ll f(ll x) const { return a * x + b; }",
    "    };",
    "    line id_line() const{ return is_min ? line(0, INF) : line(0, MINF);}",
    "",
    "    vector<line> v;",
    "    bool is_min = 1; ll idx = 0;",
    "    _cht(bool is_min = 1) : is_min(is_min) {}",
    "    void clear(){ v.clear(); idx = 0; }",
    "",
    "    bool chk(const line& a, const line& b, const line& c) const{",
    "        i128 x1 = (i128)(a.b - b.b) * (c.a - b.a), x2 = (i128)(b.b - c.b) * (b.a - a.a);",
    "        return is_min ? x1 <= x2 : x1 >= x2;",
    "    }",
    "",
    "    bool better(const line& a, const line& b, ll x) const{",
    "        i128 y1 = (i128)a.a * x + a.b, y2 = (i128)b.a * x + b.b;",
    "        if(y1 == y2){",
    "            // tie break",
    "        }",
    "        return is_min ? y1 <= y2 : y1 >= y2; ",
    "    }",
    "",
    "    // 기울기가 같은 두 직선을 비교",
    "    bool better_same(const line& a, const line& b) const{",
    "        if(a.b == b.b){",
    "            // tie break",
    "        }",
    "        return is_min ? a.b <= b.b : a.b >= b.b;",
    "    }",
    "",
    "    // 기울기 단조 증가 순으로 넣을 것",
    "    void add(line cur){",
    "        if (!v.empty() && v.back().a == cur.a){",
    "            if (!better_same(cur, v.back())) return;",
    "            v.pop_back();",
    "        }",
    "",
    "        while (v.size() >= 2 && chk(v[v.size() - 2], v.back(), cur)) v.pop_back();",
    "        v.push_back(cur);",
    "        if (idx >= (ll)v.size()) idx = (ll)v.size() - 1;",
    "    }",
    "",
    "    // 단조 증가 순으로 넣을 것",
    "    line ls(ll x){",
    "        if(v.empty()) return id_line();",
    "        while (idx + 1 < (ll)v.size() && better(v[idx + 1], v[idx], x)) idx++;",
    "        return v[idx];",
    "    }",
    "",
    "    line bs(ll x) const{",
    "        if(v.empty()) return id_line();",
    "        ll lo = 0, hi = (ll)v.size() - 1;",
    "        while (lo < hi){",
    "            ll mid = (lo + hi) >> 1ll;",
    "            if (better(v[mid + 1], v[mid], x)) lo = mid + 1;",
    "            else hi = mid;",
    "        }",
    "        return v[lo];",
    "    }",
    "};"
  ],
  "description": "cht"
}
}