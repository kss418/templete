{
	"sumseg": {
  "prefix": ">>sseg",
  "body": [
    "class _sseg {",
    "public:",
    "    ll n; vector <ll> seg;",
    "    _sseg(){}",
    "    _sseg(ll n) { this->n = n; seg.resize(4 * n + 1); }",
    "",
    "    ll query(ll st, ll en) { return query(st, en, 0, n); }",
    "    ll query(ll st, ll en, ll l, ll r, ll node = 1) {",
    "        if (en < l || st > r) return 0;",
    "        if (st <= l && en >= r) return seg[node];",
    "        ll mid = (l + r) >> 1;",
    "        return query(st, en, l, mid, node * 2) + query(st, en, mid + 1, r, node * 2 + 1);",
    "    }",
    "",
    "    void add(ll idx, ll val) { add(idx, val, 0, n); }",
    "    void add(ll idx, ll val, ll l, ll r, ll node = 1) {",
    "        if (idx < l || idx > r) return;",
    "        seg[node] += val;",
    "        if (l == r) return;",
    "        ll mid = (l + r) >> 1;",
    "        add(idx, val, l, mid, node * 2);",
    "        add(idx, val, mid + 1, r, node * 2 + 1);",
    "    }",
    "",
    "    ll update(ll idx, ll val) { return update(idx, val, 0, n); }",
    "    ll update(ll idx, ll val, ll l, ll r, ll node = 1) {",
    "        if (idx < l || idx > r) return seg[node];",
    "        if (l == r) return seg[node] = val;",
    "        ll mid = (l + r) >> 1;",
    "",
    "        seg[node] = update(idx, val, l, mid, node * 2);",
    "        seg[node] += update(idx, val, mid + 1, r, node * 2 + 1);",
    "        return seg[node];",
    "    }",
    "",
    "    ll cnt(ll val) { return cnt(val, 0, n); }",
    "    ll cnt(ll val, ll l, ll r, ll node = 1){",
    "        if(l == r) return r;",
    "        ll mid = (l + r) >> 1;",
    "",
    "        if(seg[node * 2] < val) return cnt(val - seg[node * 2], mid + 1, r, node * 2 + 1);",
    "        else return cnt(val, l, mid, node * 2);",
    "    }",
    "};"
  ],
  "description": "sumseg"
}
}