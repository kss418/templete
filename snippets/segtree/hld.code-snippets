{
"hld": {
  "prefix": ">>hld",
  "body": [
    "template <typename T = ll> //query type",
    "class _hld { // m = 0 정점, m = 1 간선",
    "public:",
    "    vector <vector <ll>> adj;",
    "    vector <ll> sz, top, d, in, out, p;",
    "    ll n, m, cnt = 0;",
    "",
    "    _hld() {}",
    "    _hld(ll n, ll m = 0){",
    "        this->n = n; this->m = m;",
    "        adj.resize(n + 1); sz.resize(n + 1);",
    "        in.resize(n + 1); out.resize(n + 1);",
    "        d.resize(n + 1); p.resize(n + 1);",
    "        top.resize(n + 1); ",
    "    }",
    "",
    "    void add(ll s, ll e){",
    "        addsol(s, e); addsol(e, s);",
    "    }   ",
    "    void addsol(ll s, ll e, ll c = 1){ adj[s].push_back(e); }",
    "",
    "    void dfs1(ll cur, ll pre){",
    "        sz[cur] = 1;",
    "        for(auto& nxt : adj[cur]){",
    "            if(nxt == pre) continue;",
    "            d[nxt] = d[cur] + 1; p[nxt] = cur;",
    "            dfs1(nxt, cur); sz[cur] += sz[nxt];",
    "            if(sz[nxt] > sz[adj[cur][0]]) swap(nxt, adj[cur][0]);",
    "        }",
    "    }",
    "",
    "    void dfs2(ll cur, ll pre){",
    "        in[cur] = ++cnt;",
    "        for(auto& nxt : adj[cur]){",
    "            if(nxt == pre) continue;",
    "            top[nxt] = (nxt == adj[cur][0] ? top[cur] : nxt);",
    "            dfs2(nxt, cur);",
    "        }",
    "        out[cur] = cnt;",
    "    }",
    "",
    "    void init(ll cur = 1){",
    "        dfs1(cur, -1); dfs2(cur, -1);",
    "    }",
    "",
    "    T query(ll st, ll en) { ",
    "        //_seg<>::node ret;",
    "        _prop<>::node ret;",
    "        while(top[st] != top[en]){",
    "            if(d[top[st]] < d[top[en]]) swap(st, en);",
    "            ll cur = top[st];",
    "            ret = seg.merge(ret, seg.query(in[cur], in[st], 0, n));",
    "            st = p[cur];",
    "        }",
    "",
    "        if(d[st] > d[en]) swap(st, en);",
    "        ret = seg.merge(ret, seg.query(in[st] + m, in[en], 0, n));",
    "        return ret; ",
    "    }",
    "",
    "    //void add_seg(ll idx, ll val) { seg.add(in[idx], val); }",
    "    /*",
    "    void add_lazy(ll st, ll en, ll val){",
    "        while(top[st] != top[en]){",
    "            if(d[top[st]] < d[top[en]]) swap(st, en);",
    "            ll cur = top[st];",
    "            seg.add(in[cur], in[st], val);",
    "            st = p[cur];",
    "        }",
    "",
    "        if(d[st] > d[en]) swap(st, en);",
    "        seg.add(in[st] + m, in[en], val);",
    "    }",
    "    */",
    "}; "
  ],
  "description": "hld"
}
}