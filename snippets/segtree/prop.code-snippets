{
	"prop": {
  "prefix": ">>prop",
  "body": [
    "class _prop { ",
    "public:",
    "    vector<ll> seg, lazy; ll n;",
    "",
    "    _prop(ll n) {",
    "        this->n = n; ",
    "        seg.resize(4 * n + 1); lazy.resize(4 * n + 1);",
    "    }",
    "",
    "    void propagate(ll l, ll r, ll node) {",
    "        if (!lazy[node]) return;",
    "        if (l != r) {",
    "            lazy[node * 2] += lazy[node];",
    "            lazy[node * 2 + 1] += lazy[node];",
    "        }",
    "        seg[node] += lazy[node] * (r - l + 1);",
    "        lazy[node] = 0;",
    "    }",
    "",
    "    void add(ll st, ll en, ll val) { add(st, en, val, 0, n); }",
    "    void add(ll st, ll en, ll val, ll l, ll r, ll node = 1) {",
    "        propagate(l, r, node);",
    "",
    "        if (st > r || en < l) return;",
    "        if (l >= st && r <= en) {",
    "            lazy[node] += val; propagate(l, r, node);",
    "            return;",
    "        }",
    "",
    "        ll mid = (l + r) >> 1;",
    "        add(st, en, val, l, mid, node * 2);",
    "        add(st, en, val, mid + 1, r, node * 2 + 1);",
    "",
    "        seg[node] = seg[node * 2] + seg[node * 2 + 1];",
    "    }",
    "",
    "    ll query(ll st, ll en) { return query(st, en, 0, n); }",
    "    ll query(ll st, ll en, ll l, ll r, ll node = 1) {",
    "        propagate(l, r, node);",
    "",
    "        if (st > r || en < l) return 0;",
    "        if (l >= st && r <= en) return seg[node];",
    "",
    "        ll mid = (l + r) >> 1;",
    "        ll ret = query(st, en, l, mid, node * 2);",
    "        ret += query(st, en, mid + 1, r, node * 2 + 1);",
    "",
    "        return ret;",
    "    }",
    "};"
  ],
  "description": "prop"
}
}