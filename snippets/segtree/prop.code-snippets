{
"prop": {
  "prefix": ">>prop",
  "body": [
    "class _prop { // 구간 예외 처리하기",
    "public:",
    "    ll n, sz, h;",
    "    class node{",
    "    public:",
    "        ll v, c;",
    "        node() : node(0, 0){} // identity",
    "        node(ll v, ll c) : v(v), c(c) {}",
    "        operator ll(){ // query",
    "            return v;",
    "        }",
    "    }; vector <node> seg;",
    "",
    "    class lazy{",
    "    public:",
    "        ll v;",
    "        lazy() : lazy(0){} // identity",
    "        lazy(ll v) : v(v){}",
    "        bool is_id(){ return !v; }",
    "    }; vector <lazy> lz;",
    "",
    "    _prop(){}",
    "    _prop(ll n) : n(n){ ",
    "        sz = 1; while(sz < n + 1) sz <<= 1ll;",
    "        h = __lg(sz);",
    "        seg.assign(2 * sz, node());",
    "        lz.assign(2 * sz, lazy());",
    "    }",
    "",
    "    void build(ll idx){",
    "        while(idx > 1){",
    "            idx >>= 1;",
    "            seg[idx] = merge(seg[idx << 1], seg[idx << 1 | 1]);",
    "            if(lz[idx].is_id()) continue;",
    "            prop(seg[idx], lz[idx]);",
    "        }",
    "    }",
    "",
    "    void push(ll idx){",
    "        for(int i = h;i > 0;i--){",
    "            ll cur = idx >> i;",
    "            if(lz[cur].is_id()) continue;",
    "            apply(cur << 1, lz[cur]);",
    "            apply(cur << 1 | 1, lz[cur]);",
    "            lz[cur] = lazy();",
    "        }",
    "    }",
    "",
    "    void apply(ll idx, lazy& now){",
    "        prop(seg[idx], now);",
    "        if(idx < sz) comp(lz[idx], now); ",
    "    }",
    "",
    "    node merge(node& l, node& r){ // node + node",
    "        return{",
    "            l.v + r.v,",
    "            l.c + r.c",
    "        };",
    "    }",
    "",
    "    void prop(node& seg, lazy& lz){ // lazy -> node",
    "        seg.v += lz.v * seg.c;",
    "    }",
    "",
    "    void comp(lazy& s, lazy& p){ // lazy -> lazy",
    "        s.v += p.v;",
    "    }",
    "",
    "    node query(ll idx){ return query(idx, idx); }",
    "    node query(ll st, ll en) {",
    "        st = max(0ll, st); en = min(n, en);",
    "        if(st > en) return node();",
    "",
    "        ll l = st + sz, r = en + sz;",
    "        push(l); push(r);",
    "",
    "        node nl, nr;",
    "        while(l <= r){",
    "            if(l & 1) nl = merge(nl, seg[l++]);",
    "            if(!(r & 1)) nr = merge(seg[r--], nr);",
    "            l >>= 1; r >>= 1;",
    "        }",
    "",
    "        return merge(nl, nr);",
    "    }",
    "",
    "    void update(ll idx, lazy lz){ update(idx, idx, lz); }",
    "    void update(ll st, ll en, lazy lz){",
    "        st = max(0ll, st); en = min(n, en);",
    "        if(st > en) return;",
    "",
    "        ll l = st + sz, r = en + sz;",
    "        ll tl = l, tr = r;",
    "        push(l); push(r);",
    "",
    "        while(l <= r){",
    "            if(l & 1) apply(l++, lz);",
    "            if(!(r & 1)) apply(r--, lz);",
    "            l >>= 1; r >>= 1l;",
    "        }",
    "        ",
    "        build(tl); build(tr);",
    "    }",
    "",
    "    void set(ll idx, node now){",
    "        if(idx < 0 || idx > n) return;",
    "        idx += sz;",
    "        seg[idx] = now;",
    "    }",
    "",
    "    void init(){",
    "        for(int i = sz - 1;i >= 1;i--){",
    "            seg[i] = merge(seg[i << 1], seg[i << 1 | 1]);",
    "        }",
    "    }",
    "",
    "    void clear(){ ",
    "        fill(all(seg), node()); ",
    "        fill(all(lz), lazy());",
    "    }",
    "};"
  ],
  "description": "prop"
}
}