{
"prop": {
  "prefix": ">>prop",
  "body": [
    "struct action{",
    "    struct node{",
    "        ll v; int sz;",
    "        node(ll v, int sz) : v(v), sz(sz){}",
    "        node() : node(0, 0){} // identity",
    "    };",
    "",
    "    struct lazy{",
    "        ll v;",
    "        lazy(ll v) : v(v){}",
    "        lazy() : lazy(0){} // identity",
    "    };",
    "",
    "    static node op(const node& l, const node& r){",
    "        return{",
    "            l.v + r.v,",
    "            l.sz + r.sz",
    "        };",
    "    }",
    "    static bool is_lz_id(const lazy& lz){ return lz.v == 0; }",
    "    static void apply(node& seg, const lazy& lz){",
    "        seg.v += lz.v * seg.sz;",
    "    }",
    "    static void compose(lazy& s, const lazy& p){",
    "        s.v += p.v;",
    "    }",
    "};",
    "",
    "template <class policy = action>",
    "class _prop {",
    "public:",
    "    using node = typename policy::node;",
    "    using lazy = typename policy::lazy;",
    "    node op(const node& l, const node& r) const{ return policy::op(l, r); }",
    "    node id() const{ return node(); }",
    "private:",
    "    vector <node> seg; vector <lazy> lz; int sz, h, n;",
    "    lazy lz_id() const{ return lazy(); }",
    "    bool is_lz_id(const lazy& now) const{ return policy::is_lz_id(now); }",
    "    void prop(node& seg, const lazy& lz) const{ policy::apply(seg, lz); }",
    "    void comp(lazy& s, const lazy& p) const{ policy::compose(s, p); }",
    "",
    "    void push(int idx){",
    "        if(is_lz_id(lz[idx])) return;",
    "        apply(idx << 1, lz[idx]);",
    "        apply(idx << 1 | 1, lz[idx]);",
    "        lz[idx] = lz_id();",
    "    }",
    "",
    "    void propagate(int idx){",
    "        for(int i = h;i > 0;i--){",
    "            int cur = idx >> i;",
    "            push(cur);",
    "        }",
    "    }",
    "",
    "    void apply(int idx, const lazy& now){",
    "        prop(seg[idx], now);",
    "        if(idx < sz) comp(lz[idx], now); ",
    "    }",
    "",
    "    void rebuild(int idx){",
    "        while(idx > 1){",
    "            idx >>= 1;",
    "            seg[idx] = op(seg[idx << 1], seg[idx << 1 | 1]);",
    "            if(is_lz_id(lz[idx])) continue;",
    "            prop(seg[idx], lz[idx]);",
    "        }",
    "    }",
    "public:",
    "    _prop(int n = 0){ clear(n); } // O(n)",
    "    _prop(const vector<node>& arr){ build(arr); } // O(n)",
    "    void clear(int n){ // O(n)",
    "        this->n = n;",
    "        sz = 1; while(sz < n + 1) sz <<= 1;",
    "        h = __lg(sz);",
    "        seg.assign(2 * sz, id());",
    "        lz.assign(2 * sz, lz_id());",
    "    }",
    "",
    "    void build(const vector<node>& arr){ // O(n)",
    "        if(arr.empty()){ clear(0); return; }",
    "        clear((int)arr.size() - 1);",
    "        for(int i = 0;i < (int)arr.size();i++) seg[i + sz] = arr[i];",
    "        for(int i = sz - 1;i >= 1;i--) seg[i] = op(seg[i << 1], seg[i << 1 | 1]);",
    "    }",
    "",
    "    node query(int idx){ return query(idx, idx); } // O(log n)",
    "    node query(int st, int en) { // O(log n)",
    "        st = max(0, st); en = min(n, en);",
    "        if(st > en) return id();",
    "",
    "        int l = (int)st + sz, r = (int)en + sz;",
    "        propagate(l); propagate(r);",
    "",
    "        node nl = id(), nr = id();",
    "        while(l <= r){",
    "            if(l & 1) nl = op(nl, seg[l++]);",
    "            if(!(r & 1)) nr = op(seg[r--], nr);",
    "            l >>= 1; r >>= 1;",
    "        }",
    "",
    "        return op(nl, nr);",
    "    }",
    "",
    "    void update(int idx, const lazy& lz){ update(idx, idx, lz); } // O(log n)",
    "    void update(int st, int en, const lazy& lz){ // O(log n)",
    "        st = max(0, st); en = min(n, en);",
    "        if(st > en) return;",
    "",
    "        int l = (int)st + sz, r = (int)en + sz;",
    "        int tl = l, tr = r;",
    "        propagate(l); propagate(r);",
    "",
    "        while(l <= r){",
    "            if(l & 1) apply(l++, lz);",
    "            if(!(r & 1)) apply(r--, lz);",
    "            l >>= 1; r >>= 1;",
    "        }",
    "        ",
    "        rebuild(tl); rebuild(tr);",
    "    }",
    "",
    "    template<class F>",
    "    int max_right(int l, const F& f){ // O(log n)",
    "        assert(0 <= l && l <= n); assert(f(id()));",
    "        l += sz; propagate(l); node v = id();",
    "        while(true){",
    "            while((l & 1) == 0) l >>= 1;",
    "            if(!f(op(v, seg[l]))){",
    "                while(l < sz){",
    "                    push(l);",
    "                    l <<= 1;",
    "                    if(f(op(v, seg[l]))){",
    "                        v = op(v, seg[l]);",
    "                        l++;",
    "                    }",
    "                }",
    "                return l - sz - 1;",
    "            }",
    "            v = op(v, seg[l]); l++;",
    "            if((l & -l) == l) break;",
    "        }",
    "        return n;",
    "    }",
    "",
    "    template<class F>",
    "    int min_left(int r, const F& f){ // O(log n)",
    "        assert(0 <= r && r <= n); assert(f(id()));",
    "        r = r + 1 + sz; propagate(r - 1); node v = id();",
    "        while(true){",
    "            r--;",
    "            while(r > 1 && (r & 1)) r >>= 1;",
    "            if(!f(op(seg[r], v))){",
    "                while(r < sz){",
    "                    push(r);",
    "                    r = r << 1 | 1;",
    "                    if(f(op(seg[r], v))){",
    "                        v = op(seg[r], v);",
    "                        r--;",
    "                    }",
    "                }",
    "                return r + 1 - sz;",
    "            }",
    "            v = op(seg[r], v);",
    "            if((r & -r) == r) break;",
    "        }",
    "        return 0;",
    "    }",
    "};"
  ],
  "description": "prop"
}
}
