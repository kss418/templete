{
"seg": {
  "prefix": ">>seg",
  "body": [
    "struct seg_policy{",
    "    struct node { ll v; };",
    "    static node id(){ return node{0}; }",
    "    static node op(const node& l, const node& r){",
    "        return node{",
    "            l.v + r.v",
    "        };",
    "    }",
    "};",
    "",
    "template <class policy = seg_policy>",
    "class _seg {",
    "private:",
    "    using node = typename policy::node;",
    "    int n, sz; vector <node> seg;",
    "    node op(const node& l, const node& r) const{ return policy::op(l, r); }",
    "    node id() const{ return policy::id(); }",
    "public:",
    "    _seg(int n = 0){ clear(n); }",
    "    void clear(int n){ ",
    "        this->n = n;",
    "        sz = 1; while(sz < n + 1) sz <<= 1;",
    "        seg.assign(2 * sz, id()); ",
    "    }",
    "",
    "    node query(int st, int en) {",
    "        st = max(0, st); en = min(n, en);",
    "        if(st > en) return id();",
    "        node l = id(), r = id();",
    "        st += sz; en += sz;",
    "        while(st <= en){",
    "            if(st & 1) l = op(l, seg[st++]);",
    "            if(!(en & 1)) r = op(seg[en--], r);",
    "            st >>= 1; en >>= 1; ",
    "        }",
    "        return op(l, r);",
    "    }",
    "",
    "    void set(int idx, node v){",
    "        if(idx < 0 || idx > n) return;",
    "        int p = idx + sz; seg[p] = v;",
    "        for(p >>= 1; p; p >>= 1) seg[p] = op(seg[p << 1], seg[p << 1 | 1]);",
    "    }",
    "};"
  ],
  "description": "seg"
}
}
