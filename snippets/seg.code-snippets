{
"seg": {
  "prefix": ">>seg",
  "body": [
    "struct monoid{",
    "    struct node {",
    "        ll v;",
    "        node(ll v = 0) : v(v){}",
    "    };",
    "    static node op(const node& l, const node& r){",
    "        return {",
    "            l.v + r.v",
    "        };",
    "    }",
    "};",
    "",
    "template <class policy = monoid>",
    "class _seg {",
    "public:",
    "    using node = typename policy::node;",
    "    node op(const node& l, const node& r) const{ return policy::op(l, r); }",
    "    node id() const{ return node(); }",
    "private:",
    "    int n, sz; vector <node> seg;",
    "    node join(const node& a, const node& b, bool right) const{ return right ? op(a, b) : op(b, a); }",
    "    template<class F>",
    "    int bisect(int p, bool right, const F& f) {",
    "        assert(0 <= p && p <= n); assert(f(id()));",
    "        if(right) { if (p == n) return n; }",
    "        else { if (p == 0) return 0; }",
    "        int i = right ? (p + sz) : (p + 1 + sz); node v = id();",
    "        while(1){",
    "            if(!right) --i;",
    "            if(right) while ((i & 1) == 0) i >>= 1;",
    "            if(!right) while (i > 1 && (i & 1)) i >>= 1;",
    "            node tmp1 = join(v, seg[i], right);",
    "            if (!f(tmp1)) {",
    "                while (i < sz) {",
    "                    i = (i << 1) | (!right);         ",
    "                    node tmp2 = join(v, seg[i], right);",
    "                    if(f(tmp2)){ v = tmp2; i += right ? 1 : -1; }",
    "                }",
    "                return right ? (i - sz - 1) : (i + 1 - sz);",
    "            }",
    "            v = tmp1;",
    "            if(right) ++i; if((i & -i) == i) break;",
    "        }",
    "        return right ? n : 0;",
    "    }",
    "public:",
    "    _seg(int n = 0){ clear(n); } // O(n)",
    "    _seg(span<const node> arr){ build(arr); } // O(n)",
    "    void clear(int n){ // O(n)",
    "        this->n = n;",
    "        sz = 1; while(sz < n + 1) sz <<= 1;",
    "        seg.assign(2 * sz, id());",
    "    }",
    "",
    "    void build(span<const node> arr){ // O(n)",
    "        if(arr.empty()){ clear(0); return; }",
    "        clear((int)arr.size() - 1);",
    "        for(int i = 0;i < (int)arr.size();i++) seg[i + sz] = arr[i];",
    "        for(int i = sz - 1;i >= 1;i--) seg[i] = op(seg[i << 1], seg[i << 1 | 1]);",
    "    }",
    "",
    "    node query(int st, int en){ // O(log n)",
    "        st = max(0, st); en = min(n, en);",
    "        if(st > en) return id();",
    "        node l = id(), r = id();",
    "        st += sz; en += sz;",
    "        while(st <= en){",
    "            if(st & 1) l = op(l, seg[st++]);",
    "            if(!(en & 1)) r = op(seg[en--], r);",
    "            st >>= 1; en >>= 1; ",
    "        }",
    "        return op(l, r);",
    "    }",
    "",
    "    void set(int idx, const node& v){ // O(log n)",
    "        if(idx < 0 || idx > n) return;",
    "        int p = idx + sz; seg[p] = v;",
    "        for(p >>= 1; p; p >>= 1) seg[p] = op(seg[p << 1], seg[p << 1 | 1]);",
    "    }",
    "",
    "    template<class F>",
    "    int max_right(int l, const F& f){ return bisect(l, 1, f); } // O(log n)",
    "",
    "    template<class F>",
    "    int min_left(int r, const F& f){  return bisect(r, 0, f); } // O(log n)",
    "};"
  ],
  "description": "seg"
}
}
