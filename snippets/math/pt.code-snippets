{
"pt": {
  "prefix": ">>pt",
  "body": [
    "class _pt{",
    "public:",
    "    vector <ll> arr; _crt crt;",
    "    void add(ll v){ // O(1) ",
    "        if(!arr.empty() && arr.back() <= 1) return;",
    "        arr.push_back(v); ",
    "    }",
    "",
    "    void add_mod(ll p, ll e){ // O(sqrt(n) * log n)",
    "        ll mod = 1;",
    "        for(int i = 1;i <= e;i++) mod *= p;",
    "        crt.add(cal(0, mod), mod); ",
    "    }",
    "",
    "    void add_mod(ll m){ // O(sqrt(n) * log n)",
    "        for(ll i = 2;i * i <= m;i++){",
    "            if(m % i) continue; ll c = 0;",
    "            while(m % i == 0) m /= i, c++;",
    "            add_mod(i, c);",
    "        }",
    "        if(m > 1) add_mod(m, 1);",
    "    }",
    "",
    "    i128 mul_cap(ll a, ll b, ll cap){",
    "        if(!a || !b) return 0;",
    "        if(a >= cap) return cap;",
    "        i128 ret = (i128)a * b;",
    "        return (ret >= (i128)cap) ? cap : ret; ",
    "    }",
    "",
    "    ll pow_cap(ll a, ll b, ll cap){",
    "        i128 ret = 1;",
    "        while(b){",
    "            if(b & 1){",
    "                ret = mul_cap(ret, a, cap);",
    "                if(ret >= cap) return cap;",
    "            }",
    "            b >>= 1ll;",
    "            if(!b) break;",
    "            a = mul_cap(a, a, cap);",
    "            if (a >= cap) a = cap;",
    "        }",
    "        return ret;",
    "    }",
    "",
    "    ll pow_mod(ll a, ll b, ll p){ return _mint(p, a).pow(b).v; }",
    "    ll cal_phi(ll x){",
    "        ll ret = x;",
    "        for(ll i = 2;i * i <= x;i++){",
    "            if(x % i) continue;",
    "            while(x % i == 0) x /= i;",
    "            ret *= i - 1; ret /= i;",
    "        }",
    "        if(x > 1) ret *= x - 1, ret /= x;",
    "        return ret;",
    "    }",
    "",
    "    ll cal_exact(int cur){",
    "        if(cur + 1 == arr.size()) return arr[cur];",
    "        return pow_cap(arr[cur], cal_exact(cur + 1), 100);",
    "    }",
    "",
    "    bool tower_le(int cur, ll num){",
    "        if((int)arr.size() - cur > 4) return 0;",
    "        ll now = arr.back();",
    "        for(int i = (int)arr.size() - 2;i >= cur;i--){",
    "            if(now > num) return 0;",
    "            now = pow_cap(arr[i], now, num + 1);",
    "        }",
    "        return now <= num;",
    "    }",
    "",
    "    ll cal(int cur, ll mod){",
    "        if(mod == 1) return 0;",
    "        if(arr[cur] == 1) return 1;",
    "        if(cur + 1 == arr.size()) return _mint(mod, arr[cur]).v;",
    "        if(tower_le(cur + 1, 100)) return pow_mod(arr[cur], cal_exact(cur + 1), mod);",
    "        ll phi = cal_phi(mod), e = cal(cur + 1, phi) + 100 * phi;",
    "        return pow_mod(arr[cur], e, mod);",
    "    }",
    "",
    "    ll ret(){ return crt.ret().x; } ",
    "};"
  ],
  "description": "pt"
}
}