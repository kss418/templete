{
  "floyd": {
    "prefix": ">>floyd",
    "body": [
      "struct sp_policy{",
      "    using dist = ll; using cost = ll;",
      "    static dist add(const dist& d, const cost& w){ // dist + cost",
      "        return d + w;",
      "    }",
      "    static bool leq(const dist& a, const dist& b){ // dist a <= dist b",
      "        return a <= b;",
      "    }",
      "    static dist inf(){ // ll -> INF, pll -> {INF, INF}, tll -> {INF, INF, INF}",
      "        return INF;",
      "    }",
      "    static dist zero(){ // ll -> 0, pll -> {0, 0}, tll -> {0, 0, 0}",
      "        return 0;",
      "    }",
      "};",
      "",
      "template <class policy = sp_policy> // 1-based index",
      "class _floyd { // ret(i,j) == INF 처리하기",
      "private:",
      "    using dist = typename policy::dist; using cost = typename policy::cost;",
      "    vector <vector<dist>> d; vector <vector<int>> nxt; ",
      "    int n; bool built = 0;",
      "",
      "    static bool less(const dist& a, const dist& b){ return policy::leq(a, b) && !policy::leq(b, a); }",
      "    static bool eq(const dist& a, const dist& b){ return policy::leq(a, b) && policy::leq(b, a); }",
      "    void chk(int st, int en) const{ assert(built); assert(st >= 0 && st <= n); assert(en >= 0 && en <= n); }",
      "public:",
      "    _floyd(int n = 0){ clear(n); }",
      "",
      "    void clear(int n = 0){ // O(n^2)",
      "        this->n = n; built = 0;",
      "        d.assign(n + 1, vector<dist>(n + 1, policy::inf()));",
      "        nxt.assign(n + 1, vector<int>(n + 1, 0));",
      "    }",
      "",
      "    void add(int st, int en, cost c) { // O(1)",
      "        if(less(c, d[st][en])) d[st][en] = c;",
      "        if(less(c, d[en][st])) d[en][st] = c;",
      "        nxt[st][en] = en; nxt[en][st] = st;",
      "    }",
      "",
      "    void addsol(int st, int en, cost c) { // O(1)",
      "        if(less(c, d[st][en])) d[st][en] = c;",
      "        nxt[st][en] = en;",
      "    }",
      "",
      "    void init() {",
      "        built = 1;",
      "        for (int k = 1; k <= n; k++) {",
      "            for (int i = 1; i <= n; i++) {",
      "                for (int j = 1; j <= n; j++) {",
      "                    dist nd = policy::add(d[i][k], d[k][j]);",
      "                    if (policy::leq(d[i][j], nd)) continue;",
      "                    d[i][j] = nd; nxt[i][j] = nxt[i][k];",
      "                }",
      "            }",
      "        }",
      "    }",
      "",
      "    dist ret(int st, int en) {",
      "        chk(st, en);",
      "        return d[st][en];",
      "    }",
      "",
      "    bool reachable(int st, int en) {",
      "        chk(st, en);",
      "        return !eq(d[st][en], policy::inf());",
      "    }",
      "",
      "    vector <int> get_path(int st, int en) {",
      "        chk(st, en); vector <int> ret;",
      "        for(int cur = en; cur != -1; cur = pre[cur]) ret.push_back(cur);",
      "        reverse(all(ret));",
      "        return ret;",
      "    }",
      "};"
    ],
    "description": "floyd"
  }
}
