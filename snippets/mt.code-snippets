{
"merge sort tree": {
  "prefix": ">>mt",
  "body": [
    "class _mt{ // 1-based index",
    "public:",
    "    vector <ll> arr; int n;",
    "    vector <vector <ll>> tree;",
    "    _mt() : n(0){} ",
    "    _mt(int n){ init(n); }",
    "    _mt(const vector <ll>& a){ build(a); }",
    "",
    "    void init(int n){",
    "        this->n = n;",
    "        arr.assign(n + 1, 0);",
    "        tree.assign(4 * n + 4, {});",
    "    }",
    "",
    "    void build(const vector <ll>& a){",
    "        n = (int)a.size() - 1;",
    "        arr = a;",
    "        tree.assign(4 * n + 4, {});",
    "        build(1, n);",
    "    }",
    "",
    "    void set(int idx, ll val){ arr[idx] = val; }",
    "    void build(){ if(n) build(1, n); }",
    "",
    "    ll greater(int s, int e, ll val){ return query(s, e, 1, n, val, true); }",
    "    ll less(int s, int e, ll val){ return query(s, e, 1, n, val, false); }",
    "",
    "private:",
    "    void build(int l, int r, int node = 1){",
    "        vector <ll>& cur = tree[node];",
    "        cur.clear();",
    "        if(l == r){",
    "            cur.push_back(arr[l]);",
    "            return;",
    "        }",
    "",
    "        int mid = (l + r) >> 1;",
    "        build(l, mid, node * 2);",
    "        build(mid + 1, r, node * 2 + 1);",
    "",
    "        vector <ll>& lv = tree[node * 2], &rv = tree[node * 2 + 1];",
    "        cur.resize(lv.size() + rv.size());",
    "        merge(all(lv), all(rv), cur.begin());",
    "    }",
    "",
    "    ll query(int s, int e, int l, int r, ll val, bool is_greater, int node = 1){",
    "        if(s > e) return 0;",
    "        if(l > e || r < s) return 0;",
    "        if(l >= s && r <= e){",
    "            vector <ll>& cur = tree[node];",
    "            if(is_greater) return cur.end() - upper_bound(all(cur), val);",
    "            return lower_bound(all(cur), val) - cur.begin();",
    "        }",
    "",
    "        int mid = (l + r) >> 1;",
    "        ll ret = query(s, e, l, mid, val, is_greater, node * 2);",
    "        ret += query(s, e, mid + 1, r, val, is_greater, node * 2 + 1);",
    "        return ret;",
    "    }",
    "};"
  ],
  "description": "merge sort tree"
}
}
