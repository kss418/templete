{
"merge sort tree": {
  "prefix": ">>mt",
  "body": [
    "struct mt_policy {",
    "    struct node {",
    "        ll v;",
    "        node(ll v) : v(v){}",
    "        node() : node(0){} // identity",
    "        bool operator < (const node& ot) const{ return v < ot.v; }",
    "    };",
    "};",
    "",
    "template <class policy = mt_policy>",
    "class _mt{ // 0-based index",
    "public:",
    "    using node = typename policy::node;",
    "private:",
    "    vector <vector <node>> seg;",
    "    vector <node> arr; int n, sz = 1;",
    "    static int count_node(const vector<node>& cur, const node& v, bool is_greater, bool is_less, bool is_eq){",
    "        int ret = 0;",
    "        auto lb = lower_bound(cur.begin(), cur.end(), v);",
    "        auto ub = upper_bound(cur.begin(), cur.end(), v);",
    "        if(is_eq) ret += (int)(ub - lb);                  ",
    "        if(is_greater) ret += (int)(cur.end() - ub);",
    "        if(is_less) ret += (int)(lb - cur.begin());",
    "        return ret; ",
    "    }",
    "",
    "    int query(int st, int en, const node& v, bool is_greater, bool is_less, bool is_eq) const{",
    "        st = max(st, 0); en = min(en, n);",
    "        if(n <= 0 || st > en) return 0;",
    "        int l = sz + st, r = sz + en, ret = 0;",
    "        while(l <= r){",
    "            if(l & 1) ret += count_node(seg[l++], v, is_greater, is_less, is_eq);",
    "            if(!(r & 1)) ret += count_node(seg[r--], v, is_greater, is_less, is_eq);",
    "            l >>= 1; r >>= 1;",
    "        }",
    "        return ret;",
    "    }",
    "public:",
    "    _mt(int n = 0){ clear(n); } // O(n)",
    "    _mt(const vector <node>& arr){ build(arr); } // O(n log n)",
    "    void clear(int n){ // O(n)",
    "        this->n = n; sz = 1; while(sz < n + 1) sz <<= 1; ",
    "        arr.assign(n + 1, node()); seg.assign(2 * sz, {});",
    "    }",
    "",
    "    void build(const vector <node>& arr){ // O(n log n)",
    "        clear((int)arr.size() - 1); this->arr = arr; ",
    "        for(int i = 0; i <= n; i++) seg[sz + i].assign(1, arr[i]);",
    "        for(int i = sz - 1; i >= 1; i--){",
    "            auto &l = seg[i << 1], &r = seg[i << 1 | 1], &cur = seg[i];",
    "            cur.resize(l.size() + r.size());",
    "            merge(all(l), all(r), cur.begin());",
    "        }",
    "    }",
    "",
    "    void update(int idx, const node& v){ // O(n)",
    "        if(idx < 0 || idx > n) return; arr[idx] = v;",
    "        int p = sz + idx; seg[p].assign(1, v); ",
    "        for(int i = p >> 1;i >= 1;i >>= 1){",
    "            auto &l = seg[i << 1], &r = seg[i << 1 | 1], &cur = seg[i];",
    "            cur.resize(l.size() + r.size());",
    "            merge(all(l), all(r), cur.begin());",
    "        }",
    "    }",
    "",
    "    int greater(int st, int en, const node& v) const{ return query(st, en, v, 1, 0, 0); } // O(log^2 n)",
    "    int less(int st, int en, const node& v) const{ return query(st, en, v, 0, 1, 0); } // O(log^2 n)",
    "    int geq(int st, int en, const node& v) const{ return query(st, en, v, 1, 0, 1); } // O(log^2 n)",
    "    int leq(int st, int en, const node& v) const{ return query(st, en, v, 0, 1, 1); } // O(log^2 n)",
    "    int eq(int st, int en, const node& v) const{ return query(st, en, v, 0, 0, 1); } // O(log^2 n)",
    "};"
  ],
  "description": "merge sort tree"
}
}
