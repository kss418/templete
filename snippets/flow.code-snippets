{
"flow": {
  "prefix": ">>flow",
  "body": [
    "class _flow {",
    "private:",
    "    vector <int> d, w; int n;",
    "    class edge {",
    "    public:",
    "        int nxt, rev; ll c, cap;",
    "        edge(int nxt, int rev, ll c) : nxt(nxt), rev(rev), c(c), cap(c) {}",
    "    };",
    "    vector <vector<edge>> adj;",
    "    bool bfs(int st, int en) { ",
    "        memset(d.data(), -1, sizeof(int) * (n + 1));",
    "        queue <int> q; q.push(st); d[st] = 0;",
    "        while (!q.empty()) {",
    "            int cur = q.front(); q.pop();",
    "            for (auto& e : adj[cur]) {",
    "                if(e.c <= 0) continue;",
    "                int nxt = e.nxt;",
    "                if (d[nxt] != -1) continue;",
    "                d[nxt] = d[cur] + 1; q.push(nxt);",
    "            }",
    "        }",
    "        return d[en] != -1;",
    "    }",
    "",
    "    ll dfs(int cur, int en, ll val) { ",
    "        if (cur == en) return val;",
    "        int &i = w[cur], sz = (int)adj[cur].size();",
    "        for(;i < sz;++i){",
    "            edge &e = adj[cur][i];",
    "            if(e.c <= 0) continue;",
    "            int nxt = e.nxt;",
    "            if(d[nxt] != d[cur] + 1) continue;",
    "            ll mn = dfs(nxt, en, min(val, e.c));",
    "            if(mn <= 0) continue;",
    "            e.c -= mn; adj[nxt][e.rev].c += mn;",
    "            return mn;",
    "        }",
    "        return 0;",
    "    }",
    "public:",
    "    _flow(int n = 0){ clear(n); } // O(n)",
    "    void clear(int n){ // O(n)",
    "        this->n = n; adj.assign(n + 1, {});",
    "        d.assign(n + 1, -1); w.assign(n + 1, 0);",
    "    }",
    "",
    "    void addsol(int st, int en, ll c = 1){  // O(1)",
    "        int re = (int)adj[en].size(), rs = (int)adj[st].size();",
    "        adj[st].push_back({en, re, c});",
    "        adj[en].push_back({st, rs, 0});",
    "    }",
    "",
    "    void add(int st, int en, ll c){ // O(1)",
    "        addsol(st, en, c); addsol(en, st, c);",
    "    }",
    "",
    "    ll ret(int st, int en){ // O(n^2 * m)",
    "        ll r = 0;",
    "        while(bfs(st, en)){",
    "            memset(w.data(), 0, sizeof(int) * (n + 1));",
    "            while(1){",
    "                ll f = dfs(st, en, INF);",
    "                if(!f) break; r += f;",
    "            }",
    "        }",
    "        return r;",
    "    }",
    "",
    "    template <class F>",
    "    void it_idx(int idx, const F& f) const{ // O(|adj[idx]|)",
    "        for(auto& [nxt, rev, c, cap] : adj[idx]){",
    "            if(!cap || cap - c < 0) continue;",
    "            f(idx, nxt, cap - c);",
    "        }",
    "    }",
    "",
    "    template <class F>",
    "    void it_all(const F& f) const{ // O(m)",
    "        for(int i = 0;i <= n;i++) it_idx(i, f);",
    "    }",
    "};"
  ],
  "description": "flow"
}
}
