{
"uf": {
  "prefix": ">>uf",
  "body": [
    "struct uf_policy{",
    "    struct node{",
    "        node(){} // identity",
    "    };",
    "    static void merge(node& a, node& b){}",
    "};",
    "",
    "template <class policy = uf_policy>",
    "class _uf{",
    "private:",
    "    using node = typename policy::node;",
    "    vector<node> arr;",
    "    vector<int> p, sz; int n, cc;",
    "    node id() const{ return node(); }",
    "public:",
    "    _uf(int n = 0){ clear(n); } // O(n)",
    "    void clear(int n){ // O(n)",
    "        this->n = n; cc = n;",
    "        p.assign(n + 1, -1); sz.assign(n + 1, 1);",
    "        arr.assign(n + 1, id());",
    "    }",
    "",
    "    int find(int x){ // O(1)",
    "        if(p[x] == -1) return x;",
    "        return p[x] = find(p[x]);",
    "    }",
    "",
    "    bool merge(int a, int b){ // O(1) + policy::merge",
    "        a = find(a); b = find(b);",
    "        if(a == b) return false;",
    "        if(sz[a] < sz[b]) swap(a, b);",
    "        p[b] = a; sz[a] += sz[b]; cc--;",
    "        policy::merge(arr[a], arr[b]); arr[b] = id();",
    "        return true;",
    "    }",
    "",
    "    int count() const{ return cc; } // O(1)",
    "    node& get(int x){ return arr[find(x)]; } // O(1)",
    "    void set(int x, const node& v){ arr[find(x)] = v; } // O(1)",
    "    int size(int x){ return sz[find(x)]; } // O(1)",
    "    bool root(int x){ return find(x) == x; } // O(1)",
    "    bool same(int a, int b){ return find(a) == find(b); } // O(1)",
    "};"
  ],
  "description": "uf"
}
}
