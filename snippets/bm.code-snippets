{
	"bm": {
  "prefix": ">>bm",
  "body": [
    "class _bm { // 1-based index",
    "private:",
    "    vector<vector<int>> adj; int as, bs;",
    "    vector<int> av, bv, dist;",
    "    static constexpr int INF = 0x3f3f3f3f;",
    "    bool bfs(){",
    "        queue <int> q;",
    "        for(int i = 1;i <= as;i++){",
    "            if(av[i] == -1) dist[i] = 0, q.push(i);",
    "            else dist[i] = INF;",
    "        }",
    "        int mn = INF;",
    "        while(!q.empty()){",
    "            int cur = q.front(); q.pop();",
    "            if(dist[cur] >= mn) continue;",
    "            for(auto& nxt : adj[cur]){",
    "                int tmp = bv[nxt];",
    "                if(tmp == -1) mn = dist[cur] + 1;",
    "                else if(dist[tmp] >= INF) dist[tmp] = dist[cur] + 1, q.push(tmp);",
    "            }",
    "        }",
    "        return mn < INF;",
    "    }",
    "",
    "    bool dfs(int cur){",
    "        for(auto& nxt : adj[cur]){",
    "            int tmp = bv[nxt];",
    "            if(tmp == -1 || (dist[tmp] == dist[cur] + 1 && dfs(tmp))){",
    "                av[cur] = nxt; bv[nxt] = cur;",
    "                return true;",
    "            }",
    "        }",
    "        dist[cur] = INF; return false;",
    "    }",
    "public:",
    "    _bm(int a = 0, int b = 0){ clear(a, b); } // O(n)",
    "    void clear(int a, int b){ // O(n)",
    "        as = a; bs = b;",
    "        adj.assign(as + 1, {}); dist.assign(as + 1, 0);",
    "        av.assign(as + 1, -1); bv.assign(bs + 1, -1);",
    "    }",
    "",
    "    void addsol(int s, int e){ adj[s].push_back(e); } // O(1)",
    "    int ret(){ // O(m sqrt n)",
    "        int result = 0;",
    "        while(bfs()){",
    "            for(int i = 1;i <= as;i++){",
    "                if(av[i] != -1) continue;",
    "                result += dfs(i);",
    "            }",
    "        }",
    "        return result;",
    "    }",
    "};"
  ],
  "description": "bm"
}
}
