{
	"mcmf": {
  "prefix": ">>mcmf",
  "body": [
    "class _mcmf {",
    "public:",
    "    ll n;",
    "    vector <ll> w, in, dist, v;",
    "    deque <ll> q;",
    "",
    "    class edge {",
    "    public:",
    "        ll nxt, c, cost, f;",
    "        edge* rev;",
    "",
    "        edge(ll nxt, ll cap, ll cost) {",
    "            this->nxt = nxt; this->c = cap; this->cost = cost;",
    "            this->rev = nullptr; this->f = 0;",
    "        }",
    "",
    "        void flow(ll num) { f += num; rev->f -= num; }",
    "        ll cap() { return c - f; }",
    "    };",
    "    vector <vector<edge*>> adj;",
    "",
    "    _mcmf(ll n) {",
    "        this->n = n; adj.resize(n + 1);",
    "        w.resize(n + 1); dist.resize(n + 1);",
    "        v.resize(n + 1); in.resize(n + 1);",
    "    }",
    "",
    "    void addsol(ll st, ll en, ll c, ll cost) {",
    "        adj[st].push_back(new edge(en, c, cost));",
    "        adj[en].push_back(new edge(st, 0, -cost));",
    "        adj[st].back()->rev = adj[en].back();",
    "        adj[en].back()->rev = adj[st].back();",
    "    }",
    "",
    "",
    "    bool bfs(ll st, ll en) { // sink 도달 여부 반환",
    "        memset(&dist[0], 0x3f, sizeof(dist[0]) * dist.size());",
    "        memset(&in[0], 0, sizeof(in[0]) * in.size());",
    "        dist[st] = 0; in[st] = 1;",
    "",
    "        q.push_back(st);",
    "        while (!q.empty()) {",
    "            ll cur = q.front(); q.pop_front(); in[cur] = 0;",
    "            for (auto& edge : adj[cur]) {",
    "                ll nxt = edge->nxt;",
    "                if (!edge->cap()) continue;",
    "                if (dist[nxt] <= dist[cur] + edge->cost) continue;",
    "",
    "                dist[nxt] = dist[cur] + edge->cost;",
    "                if (!in[nxt]) { q.push_back(nxt); in[nxt] = 1; }",
    "            }",
    "        }",
    "",
    "        return dist[en] < INF;",
    "    }",
    "",
    "    ll dfs(ll cur, ll en, ll val) { // sink 도달 최대 유량 반환",
    "        v[cur] = 1; if (cur == en) return val;",
    "",
    "        while (w[cur] < adj[cur].size()) {",
    "            ll i = w[cur]; w[cur]++;",
    "            edge* edge = adj[cur][i];",
    "            ll nxt = edge->nxt;",
    "",
    "            if (!edge->cap() || v[nxt]) continue;",
    "            if (dist[nxt] != dist[cur] + edge->cost) continue;",
    "",
    "            ll mn = dfs(nxt, en, min(edge->cap(), val));",
    "            if (mn <= 0) continue; edge->flow(mn);",
    "",
    "            return mn;",
    "        }",
    "",
    "        return 0;",
    "    }",
    "",
    "    pll ret(ll st, ll en) { // cost, flow 반환",
    "        ll flow = 0, cost = 0;",
    "        while (bfs(st, en)) {",
    "            memset(&v[0], 0, sizeof(v[0]) * v.size());",
    "            memset(&w[0], 0, sizeof(w[0]) * w.size());",
    "            while (1) {",
    "                ll f = dfs(st, en, INF);",
    "                if (!f) break;",
    "                flow += f; cost += dist[en] * f;",
    "                memset(&v[0], 0, sizeof(v[0]) * v.size());",
    "            }",
    "        }",
    "",
    "        return { flow, cost };",
    "    }",
    "};"
  ],
  "description": "mcmf"
}
}