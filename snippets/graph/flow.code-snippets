{
"flow": {
  "prefix": ">>flow",
  "body": [
    "class _flow {",
    "public:",
    "    int n;",
    "    vector <int> d, w;",
    "",
    "    class edge {",
    "    public:",
    "        int nxt, rev; ll c;",
    "        edge(){}",
    "        edge(int nxt, int rev, ll c) : nxt(nxt), rev(rev), c(c) {}",
    "    };",
    "    vector <vector<edge>> adj;",
    "",
    "    _flow(int n) : n(n) {",
    "        d.resize(n + 1); w.resize(n + 1);",
    "        adj.resize(n + 1);",
    "    }",
    "",
    "    void addsol(int st, int en, ll c = 1) {",
    "        int re = (int)adj[en].size();",
    "        int rs = (int)adj[st].size();",
    "        adj[st].push_back({en, re, c});",
    "        adj[en].push_back({st, rs, 0});",
    "    }",
    "",
    "",
    "    bool bfs(int st, int en) { // sink 도달 여부 반환",
    "        memset(d.data(), -1, sizeof(int) * (n + 1));",
    "        d[st] = 0;",
    "",
    "        queue <int> q;",
    "        q.push(st);",
    "        while (!q.empty()) {",
    "            int cur = q.front(); q.pop();",
    "            for (auto& e : adj[cur]) {",
    "                if(e.c <= 0) continue;",
    "                int nxt = e.nxt;",
    "                if (d[nxt] != -1) continue;",
    "",
    "                d[nxt] = d[cur] + 1; ",
    "                if(nxt == en) return 1;",
    "                q.push(nxt);",
    "            }",
    "        }",
    "",
    "        return d[en] != -1;",
    "    }",
    "",
    "    ll dfs(int cur, int en, ll val) { // sink 도달 최대 유량 반환",
    "        if (cur == en) return val;",
    "",
    "        int &i = w[cur], sz = adj[cur].size();",
    "        for(;i < sz;++i){",
    "            edge &e = adj[cur][i];",
    "            if(e.c <= 0) continue;",
    "            int nxt = e.nxt;",
    "            if(d[nxt] != d[cur] + 1) continue;",
    "",
    "            ll mn = dfs(nxt, en, min(val, e.c));",
    "            if(mn <= 0) continue;",
    "",
    "            e.c -= mn;",
    "            adj[nxt][e.rev].c += mn;",
    "            return mn;",
    "        }",
    "",
    "        return 0;",
    "    }",
    "",
    "    ll ret(int st, int en) {",
    "        ll r = 0;",
    "        while (bfs(st, en)) {",
    "            memset(w.data(), 0, sizeof(int) * (n + 1));",
    "            while (1) {",
    "                ll f = dfs(st, en, INF);",
    "                if (!f) break;",
    "                r += f;",
    "            }",
    "        }",
    "",
    "        return r;",
    "    }",
    "};"
  ],
  "description": "flow"
}
}