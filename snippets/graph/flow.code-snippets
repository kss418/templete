{
	"flow": {
  "prefix": ">>flow",
  "body": [
    "class _flow {",
    "public:",
    "    ll n;",
    "    vector <ll> d, w;",
    "    deque <ll> q;",
    "",
    "    class edge {",
    "    public:",
    "        ll nxt, c, f;",
    "        edge* rev;",
    "",
    "        edge(ll nxt, ll c) {",
    "            this->nxt = nxt; this->c = c;",
    "            this->rev = nullptr; this->f = 0;",
    "        }",
    "",
    "        void flow(ll num) { f += num; rev->f -= num; }",
    "        ll cap() { return c - f; }",
    "    };",
    "    vector <vector<edge*>> adj;",
    "",
    "    _flow(ll n) {",
    "        this->n = n;",
    "        d.resize(n + 1); w.resize(n + 1);",
    "        adj.resize(n + 1);",
    "    }",
    "",
    "    void addsol(ll st, ll en, ll c = 1) {",
    "        adj[st].push_back(new edge(en, c));",
    "        adj[en].push_back(new edge(st, 0));",
    "        adj[st].back()->rev = adj[en].back();",
    "        adj[en].back()->rev = adj[st].back();",
    "    }",
    "",
    "",
    "    bool bfs(ll st, ll en) { // sink 도달 여부 반환",
    "        fill(d.begin(), d.end(), -1);",
    "        d[st] = 0;",
    "",
    "        q.push_back(st);",
    "        while (!q.empty()) {",
    "            ll cur = q.front(); q.pop_front();",
    "            for (auto& edge : adj[cur]) {",
    "                ll nxt = edge->nxt;",
    "                if (d[nxt] != -1) continue;",
    "                if (edge->cap() <= 0) continue;",
    "",
    "                d[nxt] = d[cur] + 1; q.push_back(nxt);",
    "            }",
    "        }",
    "",
    "        return d[en] != -1;",
    "    }",
    "",
    "    ll dfs(ll cur, ll en, ll val) { // sink 도달 최대 유량 반환",
    "        if (cur == en) return val;",
    "",
    "        while (w[cur] < adj[cur].size()) {",
    "            ll i = w[cur]; w[cur]++;",
    "            edge* edge = adj[cur][i];",
    "            ll nxt = edge->nxt;",
    "",
    "            if (d[nxt] != d[cur] + 1) continue;",
    "            if (edge->cap() <= 0) continue;",
    "",
    "            ll mn = dfs(nxt, en, min(edge->cap(), val));",
    "            if (mn <= 0) continue;",
    "            edge->flow(mn);",
    "",
    "            return mn;",
    "        }",
    "",
    "        return 0;",
    "    }",
    "",
    "    ll ret(ll st, ll en) {",
    "        ll r = 0;",
    "        while (bfs(st, en)) {",
    "            fill(w.begin(), w.end(), 0);",
    "            while (1) {",
    "                ll f = dfs(st, en, INF);",
    "                if (!f) break;",
    "                r += f;",
    "            }",
    "        }",
    "",
    "        return r;",
    "    }",
    "};",
    ""
  ],
  "description": "flow"
}
}