{
	"mst": {
  "prefix": ">>mst",
  "body": [
    "template <typename T = ll>",
    "class _mst {",
    "public:",
    "    vector<vector<pair<T, ll>>> adj;",
    "    vector<ll> p, size; T result = 0;",
    "    ll n, cnt = 0;",
    "    class edge {",
    "    public:",
    "        ll s, e; T c;",
    "        bool operator>(const edge& ot) const {",
    "            return c > ot.c;",
    "        }",
    "",
    "        bool operator<(const edge& ot) const {",
    "            return c < ot.c;",
    "        }",
    "    };",
    "    priority_queue<edge, vector<edge>, greater<edge>> pq;",
    "",
    "    _mst(ll n) {",
    "        this->n = n;",
    "        adj.resize(n + 1);",
    "        p.resize(n + 1, -1); size.resize(n + 1, 1);",
    "    }",
    "",
    "    ll find(ll num) {",
    "        if (p[num] == -1) return num;",
    "        return p[num] = find(p[num]);",
    "    }",
    "",
    "    void merge(ll a, ll b) {",
    "        a = find(a); b = find(b);",
    "        if (a == b) return;",
    "        if (a > b) swap(a, b);",
    "        p[b] = a, size[a] += size[b];",
    "    }",
    "",
    "    ll same(ll a, ll b) {",
    "        if (find(a) == find(b)) return 1;",
    "        return 0;",
    "    }",
    "",
    "    void add(ll st, ll en, T c = 1) { // 양방향",
    "        adj[st].push_back({ c, en });",
    "        adj[en].push_back({ c, st });",
    "        pq.push({ st, en, c });",
    "        pq.push({ en, st, c });",
    "    }",
    "",
    "    void init(ll num = 0) { // num 만큼 적게 간선 연결",
    "        cnt = 0; result = 0;",
    "        while (!pq.empty()) {",
    "            auto [st, en, c] = pq.top(); pq.pop();",
    "            if (same(st, en)) continue; merge(st, en);",
    "            result += c; cnt++;",
    "            if (cnt == n - 1 - num) break;",
    "        }",
    "    }",
    "",
    "    T ret() {",
    "        return result;",
    "    }",
    "};"
  ],
  "description": "mst"
}
}