{
	"spfa": {
  "prefix": ">>spfa",
  "body": [
    "template <typename T = ll>",
    "class _spfa {",
    "public:",
    "    using ptl = pair <T, ll>;",
    "    ll n; vector <ll> pre, cnt;",
    "    vector <T> d; vector <bool> in;",
    "    deque <ll> q;",
    "    vector <vector <ptl>> adj;",
    "",
    "    _spfa(ll n) {",
    "        this->n = n;",
    "        pre.resize(n + 1, -1); d.resize(n + 1, INF);",
    "        in.resize(n + 1); adj.resize(n + 1);",
    "        cnt.resize(n + 1);",
    "    }",
    "",
    "    void addsol(ll st, ll en, T c = 1) { // 단방향",
    "        adj[st].push_back({ c, en });",
    "    }",
    "",
    "    ll init(ll st, ll fi = 0) { // cycle 0 else 1 / fi = d[st]",
    "        d[st] = fi; in[st] = 1;",
    "        q.push_back(st);",
    "",
    "        while (!q.empty()) {",
    "            ll cur = q.front(); q.pop_front();",
    "            in[cur] = 0; cnt[cur]++;",
    "            ll cd = d[cur];",
    "            if (cnt[cur] > n) return 0;",
    "",
    "            for (auto& nn : adj[cur]) {",
    "                auto [nd, nxt] = nn;",
    "                if (d[nxt] <= nd + cd) continue;",
    "                d[nxt] = nd + cd;",
    "                pre[nxt] = cur;",
    "",
    "                if (in[nxt]) continue;",
    "                in[nxt] = 1;",
    "                q.push_back(nxt);",
    "            }",
    "        }",
    "",
    "        return 1;",
    "    }",
    "",
    "    T ret(ll num) { // 거리 반환",
    "        return d[num];",
    "    }",
    "",
    "    vector <ll> track(ll st, ll en) { // st -> en 경로 반환",
    "        vector <ll> ret;",
    "        ll cur = en;",
    "        while (cur != -1) {",
    "            ret.push_back(cur);",
    "            cur = pre[cur];",
    "        }",
    "        reverse(ret.begin(), ret.end());",
    "",
    "        return ret;",
    "    }",
    "};"
  ],
  "description": "spfa"
}
}