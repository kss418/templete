{
	"bfs": {
  	"prefix": ">>bfs",
  	"body": [
    "class _bfs { // 0-based index",
    "public:",
    "    ll n, m;",
    "    ll dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};",
    "    // ll dx[8] = { 1, 1, 1, 0, 0, -1, -1, -1 };",
    "    // ll dy[8] = { -1, 0, 1, -1, 1, -1, 0, 1 };",
    "",
    "    class node {",
    "    public:",
    "        ll y, x;",
    "        ll num() const{",
    "            return y * 200 + x;",
    "        }",
    "    };",
    "    deque <pair <node, ll>> q; vector <ll> v;",
    "    _bfs(){}",
    "    _bfs(ll n, ll m) { ",
    "        this->n = n; this->m = m; ",
    "        v.resize(n * m + 1, INF);",
    "    }",
    "",
    "    bool outrange(node cur){",
    "        auto[cy, cx] = cur;",
    "        if(cy < 0 || cx < 0 || cy >= n || cx >= m) return 1;",
    "        return 0;",
    "    }",
    "",
    "    void init(node st) {",
    "        q.push_back({st, 0});",
    "        while (!q.empty()) {",
    "            auto [cur, cc] = q.front(); q.pop_front();",
    "            auto [cy, cx] = cur;",
    "            if (v[cur.num()] <= cc) continue; v[cur.num()] = cc;",
    "",
    "            for(int i = 0;i < 4;i++){",
    "                ll nx = cx + dx[i], ny = cy + dy[i];",
    "                node nxt = {ny, nx};",
    "                if (outrange(nxt)) continue;",
    "                q.push_back({nxt, cc + 1});",
    "            }",
    "        }",
    "    }",
    "",
    "    ll ret(node cur) { return v[cur.num()]; }",
    "};"
  ],
  "description": "bfs"
}
}