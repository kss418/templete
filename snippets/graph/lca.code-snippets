{
"lca": {
  "prefix": ">>lca",
  "body": [
    "class _lca { // 1-based index",
    "public:",
    "    ll n, m; vector <ll> d;",
    "    vector <vector<ll>> p;",
    "    vector <vector<pll>> adj;",
    "",
    "    class node{",
    "    public:",
    "        ll v;",
    "        node() : node(0) {}",
    "        node(ll v) : v(v) {}",
    "",
    "        operator ll(){ // query",
    "            return v;",
    "        }",
    "    };",
    "    vector <vector<node>> arr;",
    "",
    "    _lca() {}",
    "    _lca(ll n, bool m = 0) { //n 개수",
    "        this->n = n; this->m = m; ",
    "        p.resize(log2(n + 1) + 1, vector<ll>(n + 1, -1));",
    "        d.resize(n + 1); adj.resize(n + 1);",
    "        fill(d.begin(), d.end(), -1);",
    "",
    "        if(m) arr.resize(log2(n + 1) + 1, vector<node>(n + 1, node()));",
    "    }",
    "",
    "    void add(ll a, ll b, ll c = 1) { // 양방향",
    "        adj[a].push_back({b, c});",
    "        adj[b].push_back({a, c});",
    "    }",
    "",
    "    void addsol(ll a, ll b, ll c = 1) { // 단방향",
    "        adj[a].push_back({b, c});",
    "    }",
    "",
    "    node merge(const node& a, const node& b){",
    "        return {",
    "            max(a.v, b.v)",
    "        };",
    "    }",
    "",
    "    node merge(ll a, const node& b){",
    "        return{",
    "            max(a, b.v)",
    "        };",
    "    }",
    "",
    "    void mktree(ll cur) {",
    "        for (auto& [nxt, co] : adj[cur]) {",
    "            if (d[nxt] != -1) continue;",
    "            p[0][nxt] = cur;",
    "            d[nxt] = d[cur] + 1;",
    "",
    "            if(m) arr[0][nxt] = co;",
    "            mktree(nxt);",
    "        }",
    "    }",
    "",
    "    void init() {",
    "        for(int i = 1;i <= n;i++){",
    "            if(d[i] != -1) continue;",
    "            d[i] = 0; mktree(i);",
    "        }",
    "",
    "        for (int i = 1; i <= log2(n); i++) {",
    "            for (int j = 1; j <= n; j++) {",
    "                if (p[i - 1][j] == -1) continue;",
    "                p[i][j] = p[i - 1][p[i - 1][j]];",
    "                if(m) arr[i][j] = merge(arr[i - 1][p[i - 1][j]], arr[i - 1][j]);",
    "            }",
    "        }",
    "    }",
    "",
    "    ll shift(ll a, ll diff){",
    "        if(diff <= 0) return a;",
    "        for (int i = log2(diff); i >= 0; i--) {",
    "            if (diff & (1ll << i)) a = p[i][a];",
    "        }",
    "",
    "        return a;",
    "    }",
    "",
    "    ll ret(ll a, ll b) {",
    "        if (d[a] < d[b]) swap(a, b);",
    "",
    "        a = shift(a, d[a] - d[b]);",
    "        if (a == b) return a;",
    "",
    "        for (int i = log2(n); i >= 0; i--) {",
    "            if (a == b) break;",
    "            if (p[i][a] == -1) continue;",
    "            if (p[i][a] == p[i][b]) continue;",
    "",
    "            a = p[i][a]; b = p[i][b];",
    "        }",
    "",
    "        return p[0][a];",
    "    }",
    "",
    "    ll num(ll a, ll b){",
    "        if(!m) return MINF;",
    "",
    "        node ret = node();",
    "        if (d[a] < d[b]) swap(a, b);",
    "",
    "        ll diff = d[a] - d[b];",
    "        if (diff) for (int i = log2(diff); i >= 0; i--) {",
    "            if (diff & (1ll << i)){",
    "                ret = merge(ret, arr[i][a]);",
    "                a = p[i][a];",
    "            }",
    "        }",
    "        if (a == b) return ret;",
    "",
    "        for (int i = log2(n); i >= 0; i--) {",
    "            if (a == b) break;",
    "            if (p[i][a] == -1) continue;",
    "            if (p[i][a] == p[i][b]) continue;",
    "",
    "            ret = merge(ret, arr[i][a]);",
    "            ret = merge(ret, arr[i][b]);",
    "            a = p[i][a]; b = p[i][b];",
    "        }",
    "",
    "        ret = merge(ret, arr[0][a]);",
    "        ret = merge(ret, arr[0][b]);",
    "        return ret;",
    "    }",
    "};"
  ],
  "description": "lca"
}
}