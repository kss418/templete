{
  "spfa": {
    "prefix": ">>spfa",
    "body": [
      "struct sp_policy{",
      "    using dist = ll; using cost = ll;",
      "    static dist add(const dist& d, const cost& w){ // dist + cost",
      "        return d + w;",
      "    }",
      "    static bool leq(const dist& a, const dist& b){ // dist a <= dist b",
      "        return a <= b;",
      "    }",
      "    static dist inf(){ // ll -> INF, pll -> {INF, INF}, tll -> {INF, INF, INF}",
      "        return INF;",
      "    }",
      "    static dist zero(){ // ll -> 0, pll -> {0, 0}, tll -> {0, 0, 0}",
      "        return 0;",
      "    }",
      "};",
      "",
      "template <class policy = sp_policy>",
      "class _spfa {",
      "private:",
      "    using dist = typename policy::dist; using cost = typename policy::cost;",
      "    struct edge{ cost w; int nxt; };",
      "    vector <int> pre, cnt; deque <int> q;",
      "    vector <dist> d; vector <bool> in;",
      "    vector <vector <edge>> adj; int n; bool built = 0;",
      "",
      "    static bool less(const dist& a, const dist& b){ return policy::leq(a, b) && !policy::leq(b, a); }",
      "    static bool eq(const dist& a, const dist& b){ return policy::leq(a, b) && policy::leq(b, a); }",
      "    bool cal(){",
      "        built = 1;",
      "        while (!q.empty()) {",
      "            int cur = q.front(); q.pop_front();",
      "            in[cur] = 0; cnt[cur]++;",
      "            dist cd = d[cur];",
      "            if (cnt[cur] > n) return 0;",
      "            for (auto& e : adj[cur]) {",
      "                auto [co, nxt] = e;",
      "                dist nd = policy::add(cd, co);",
      "                if (policy::leq(d[nxt], nd)) continue;",
      "                d[nxt] = nd; pre[nxt] = cur;",
      "                if (in[nxt]) continue;",
      "                in[nxt] = 1; q.push_back(nxt);",
      "            }",
      "        }",
      "        return 1;",
      "    }",
      "    void reset(int n){",
      "        pre.assign(n + 1, -1); cnt.assign(n + 1, 0);",
      "        d.assign(n + 1, policy::inf()); q.clear();",
      "        in.assign(n + 1, false);",
      "    }",
      "    void chk(int x) const{ assert(built); assert(x >= 0 && x <= n); }",
      "public:",
      "    _spfa(int n = 0){ clear(n); } // O(n)",
      "    void clear(int n = 0){ // O(n + m)",
      "        this->n = n; built = 0;",
      "        reset(n); adj.assign(n + 1, {});",
      "    }",
      "",
      "    void addsol(int st, int en, cost c) { // O(1)",
      "        built = 0;",
      "        adj[st].push_back({ c, en });",
      "    }",
      "    void add(int st, int en, cost c) { // O(1)",
      "        addsol(st, en, c); addsol(en, st, c);",
      "    }",
      "",
      "    // cycle existed -> return 0",
      "    bool init(int source, dist fi = policy::zero()) { // O(nm)",
      "        reset(n); d[source] = fi; in[source] = 1;",
      "        q.push_back(source);",
      "        return cal();",
      "    }",
      "",
      "    // cycle existed -> return 0",
      "    bool init(const vector <int>& source, dist fi = policy::zero()) { // O(nm)",
      "        reset(n); ",
      "        for (const auto& st : source) {",
      "            d[st] = fi; in[st] = 1;",
      "            q.push_back(st);",
      "        }",
      "        return cal();",
      "    }",
      "",
      "    dist ret(int x) const{ // O(1)",
      "        chk(x);",
      "        return d[x];",
      "    }",
      "",
      "    bool reachable(int x) const{ // O(1)",
      "        chk(x);",
      "        return !eq(d[x], policy::inf());",
      "    }",
      "",
      "    vector <int> get_path(int x) const{ // O(n) ",
      "        chk(x); assert(reachable(x));",
      "        vector <int> ret;",
      "        for(int cur = x; cur != -1; cur = pre[cur]) ret.push_back(cur);",
      "        reverse(ret.begin(), ret.end());",
      "        return ret;",
      "    }",
      "};"
    ],
    "description": "spfa"
  }
}
