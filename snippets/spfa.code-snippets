{
  "spfa": {
    "prefix": ">>spfa",
    "body": [
      "struct sp_policy{",
      "    using dist = ll; using cost = ll;",
      "    static dist add(const dist& d, const cost& w){ // dist + cost",
      "        return d + w;",
      "    }",
      "    static bool leq(const dist& a, const dist& b){ // dist a <= dist b",
      "        return a <= b;",
      "    }",
      "    static dist inf(){ // ll -> INF, pll -> {INF, INF}, tll -> {INF, INF, INF}",
      "        return INF;",
      "    }",
      "    static dist zero(){ // ll -> 0, pll -> {0, 0}, tll -> {0, 0, 0}",
      "        return 0;",
      "    }",
      "};",
      "",
      "template <class policy = sp_policy>",
      "class _spfa {",
      "private:",
      "    using dist = typename policy::dist; using cost = typename policy::cost;",
      "    struct edge{ cost w; int nxt; };",
      "    vector <int> pre, cnt; deque <int> q;",
      "    vector <dist> d; vector <bool> in;",
      "    vector <vector <edge>> adj; int n; bool built = 0;",
      "",
      "    static bool less(const dist& a, const dist& b){ return policy::leq(a, b) && !policy::leq(b, a); }",
      "    static bool eq(const dist& a, const dist& b){ return policy::leq(a, b) && policy::leq(b, a); }",
      "    void chk(int x) const{ assert(built); assert(x >= 0 && x <= n); }",
      "public:",
      "    _spfa(int n = 0){ clear(n); }",
      "",
      "    void clear(int n = 0){ // O(n + m)",
      "        this->n = n; built = 0;",
      "        pre.assign(n + 1, -1);",
      "        cnt.assign(n + 1, 0);",
      "        d.assign(n + 1, policy::inf());",
      "        in.assign(n + 1, false);",
      "        adj.assign(n + 1, {});",
      "        q.clear();",
      "    }",
      "",
      "    void add(int st, int en, cost c) { // O(1)",
      "        adj[st].push_back({ c, en });",
      "        adj[en].push_back({ c, st });",
      "    }",
      "",
      "    void addsol(int st, int en, cost c) { // O(1)",
      "        adj[st].push_back({ c, en });",
      "    }",
      "",
      "    bool init(int st, dist fi = policy::zero()) { // cycle 0 else 1 / fi = d[st]",
      "        built = 1;",
      "        d[st] = fi; in[st] = 1;",
      "        q.push_back(st);",
      "",
      "        while (!q.empty()) {",
      "            int cur = q.front(); q.pop_front();",
      "            in[cur] = 0; cnt[cur]++;",
      "            dist cd = d[cur];",
      "            if (cnt[cur] > n) return 0;",
      "",
      "            for (auto& nn : adj[cur]) {",
      "                auto [nd, nxt] = nn;",
      "                dist nxtd = policy::add(cd, nd);",
      "                if (policy::leq(d[nxt], nxtd)) continue;",
      "                d[nxt] = nxtd;",
      "                pre[nxt] = cur;",
      "",
      "                if (in[nxt]) continue;",
      "                in[nxt] = 1;",
      "                q.push_back(nxt);",
      "            }",
      "        }",
      "",
      "        return 1;",
      "    }",
      "",
      "    dist ret(int x) { // 거리 반환",
      "        chk(x);",
      "        return d[x];",
      "    }",
      "",
      "    bool reachable(int x) const { // 거리 도달 여부",
      "        chk(x);",
      "        return !eq(d[x], policy::inf());",
      "    }",
      "",
      "    vector <int> get_path(int x) { // 시작점 -> x 경로 반환",
      "        chk(x); vector <int> ret;",
      "        for(int cur = x; cur != -1; cur = pre[cur]) ret.push_back(cur);",
      "        reverse(ret.begin(), ret.end());",
      "        return ret;",
      "    }",
      "};"
    ],
    "description": "spfa"
  }
}
